<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linear RGB Resize</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
            color: #333;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }

        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .upload-box {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
        }

        .upload-box:hover {
            border-color: #3498db;
            background: #f8f9fa;
        }

        .upload-box.has-image {
            border-style: solid;
            border-color: #27ae60;
        }

        .upload-box img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 4px;
        }

        .upload-box label {
            font-weight: 600;
            color: #555;
            margin-bottom: 10px;
            display: block;
        }

        .upload-box .hint {
            color: #888;
            font-size: 14px;
        }

        input[type="file"] {
            display: none;
        }

        .options-section {
            margin-bottom: 30px;
        }

        .options-section h3 {
            margin-bottom: 15px;
            color: #555;
        }

        .option-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .option-row label {
            min-width: 120px;
            font-weight: 500;
        }

        select, input[type="number"] {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        input[type="number"] {
            width: 100px;
        }

        input[type="number"].secondary-dimension {
            color: #999;
            background: #f5f5f5;
        }

        .size-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .size-inputs span {
            color: #888;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        button:hover {
            background: #2980b9;
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .button-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .button-secondary {
            background: #95a5a6;
        }

        .button-secondary:hover {
            background: #7f8c8d;
        }

        #output-section {
            display: none;
        }

        .output-container {
            text-align: center;
        }

        .output-container canvas {
            max-width: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .output-info {
            margin-top: 15px;
            color: #666;
            font-size: 14px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            position: relative;
        }

        .loading.active {
            display: block;
        }

        .sparkle-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 280px;
            height: 100px;
            margin-left: -140px;
            margin-top: -50px;
            pointer-events: none;
        }

        .sparkle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #fff 0%, #ffd700 40%, transparent 70%);
            border-radius: 50%;
            opacity: 0;
            animation: sparkle-float 2s ease-in-out infinite;
        }

        .sparkle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #ffd700, transparent);
            transform: translate(-50%, -50%);
        }

        .sparkle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 100%;
            background: linear-gradient(180deg, transparent, #ffd700, transparent);
            transform: translate(-50%, -50%);
        }

        .sparkle:nth-child(1) { left: 5%; top: 20%; animation-delay: 0s; }
        .sparkle:nth-child(2) { left: 15%; top: 70%; animation-delay: 0.3s; }
        .sparkle:nth-child(3) { left: 25%; top: 10%; animation-delay: 0.6s; }
        .sparkle:nth-child(4) { left: 35%; top: 80%; animation-delay: 0.9s; }
        .sparkle:nth-child(5) { left: 50%; top: 5%; animation-delay: 0.15s; }
        .sparkle:nth-child(6) { left: 65%; top: 85%; animation-delay: 0.45s; }
        .sparkle:nth-child(7) { left: 75%; top: 15%; animation-delay: 0.75s; }
        .sparkle:nth-child(8) { left: 85%; top: 65%; animation-delay: 0.2s; }
        .sparkle:nth-child(9) { left: 95%; top: 25%; animation-delay: 0.5s; }
        .sparkle:nth-child(10) { left: 10%; top: 45%; animation-delay: 0.8s; }
        .sparkle:nth-child(11) { left: 90%; top: 50%; animation-delay: 0.35s; }
        .sparkle:nth-child(12) { left: 45%; top: 90%; animation-delay: 0.65s; }

        @keyframes sparkle-float {
            0%, 100% {
                opacity: 0;
                transform: scale(0) rotate(0deg);
            }
            25% {
                opacity: 1;
                transform: scale(1) rotate(90deg);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.2) rotate(180deg);
            }
            75% {
                opacity: 0.5;
                transform: scale(0.8) rotate(270deg);
            }
        }

        .error-message {
            background: #fee;
            border: 1px solid #fcc;
            color: #c00;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: none;
        }

        .error-message.visible {
            display: block;
        }

        .info-box {
            background: #e8f4f8;
            border: 1px solid #b8d4e3;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #2c5282;
        }

        .info-box strong {
            color: #1a365d;
        }

        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .comparison-box {
            text-align: center;
        }

        .comparison-box h4 {
            margin-bottom: 10px;
            color: #555;
        }

        .comparison-box canvas {
            max-width: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .comparison-container {
                grid-template-columns: 1fr;
            }
        }

        .preset-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .preset-btn {
            padding: 6px 12px;
            font-size: 13px;
            background: #ecf0f1;
            color: #555;
        }

        .preset-btn:hover {
            background: #bdc3c7;
        }

        /* Alpha checkerboard pattern for transparent images */
        .alpha-checkerboard {
            background-image:
                linear-gradient(45deg, #ccc 25%, transparent 25%),
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 16px 16px;
            background-position: 0 0, 0 8px, 8px -8px, -8px 0px;
            background-color: #fff;
        }

        .upload-box .alpha-checkerboard {
            display: inline-block;
            border-radius: 4px;
        }

        .comparison-box .alpha-checkerboard {
            display: inline-block;
            border-radius: 4px;
        }

        .init-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .init-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="init-overlay" id="init-overlay">
        <div class="spinner"></div>
        <h2>Loading Linear RGB Resize...</h2>
        <p>Initializing WASM module...</p>
    </div>

    <h1>Linear RGB Resize</h1>
    <p class="subtitle">Proper image resizing in linear color space</p>

    <div class="container">
        <div class="info-box">
            <strong>Why linear RGB?</strong> Most image resizers work in sRGB space, which causes color shifts and darkening during interpolation. This tool converts to linear RGB before resizing, then back to sRGB.
        </div>
        <p style="margin: -12px 0 20px 0; font-size: 12px; color: #888;">Linear RGB values are proportional to physical light intensity, so averaging pixels correctly simulates how light mixes. sRGB's gamma curve breaks this, making blends too dark. Uniform scaling preserves the exact aspect ratio even when the output dimensions are off by a fraction of a pixel. Floating point results are quantized to 8-bit using mixed-kernel dithering with error diffusion in linear RGB (physically correct) and perceptual nearest in OKLab (perceptually correct) - no rounding errors or drift between saves.</p>

        <div class="upload-box" id="upload-box">
            <label>Drop image here or click to upload</label>
            <p class="hint">Supports PNG, JPG, WebP</p>
            <input type="file" id="file-input" accept="image/*,.safetensors">
        </div>

        <div class="error-message" id="error-message"></div>

        <div class="options-section">
            <h3>Resize Options</h3>

            <div class="option-row">
                <label>Target Size:</label>
                <div class="size-inputs">
                    <input type="number" id="target-width" min="1" max="8192" value="256" placeholder="Width">
                    <span>x</span>
                    <input type="number" id="target-height" min="1" max="8192" value="256" placeholder="Height">
                    <span>px</span>
                </div>
            </div>

            <div class="preset-buttons">
                <button class="preset-btn" data-w="64">64px</button>
                <button class="preset-btn" data-w="128">128px</button>
                <button class="preset-btn" data-w="256">256px</button>
                <button class="preset-btn" data-w="512">512px</button>
                <button class="preset-btn" data-w="640">640px</button>
                <button class="preset-btn" data-w="1024">1024px</button>
                <button class="preset-btn" data-w="1920">1920px</button>
            </div>

            <div class="option-row" style="margin-top: 20px;">
                <label>Interpolation:</label>
                <select id="interpolation">
                    <option value="13" selected>★ EWA Lanczos3 (jinc-based, recommended)</option>
                    <option value="12">EWA Lanczos2 (jinc-based, less ringing)</option>
                    <option value="21">EWA Lanczos3 Sharp (Robidoux, preserves lines)</option>
                    <option value="22">EWA Lanczos4 Sharpest (Robidoux, hash patterns)</option>
                    <option value="1">Lanczos3 (separable, faster)</option>
                    <option value="7">Lanczos2 (separable, less ringing)</option>
                    <option value="9">EWA Sinc-Lanczos3 (radial sinc, faster)</option>
                    <option value="8">EWA Sinc-Lanczos2 (radial sinc, faster)</option>
                    <option value="3">★ Catmull-Rom (sharp, low ringing)</option>
                    <option value="2">Mitchell (soft, minimal ringing)</option>
                    <option value="15">EWA Catmull-Rom (2D, sharp)</option>
                    <option value="14">EWA Mitchell (2D, soft)</option>
                    <option value="0">★ Bilinear (faster)</option>
                    <option value="20">★ Box (nearest up, area-average down)</option>
                    <option value="4">Sinc (research only, SLOW)</option>
                    <option value="16">Jinc (2D sinc analog, research only, SLOW)</option>
                    <option value="17">Stochastic Jinc (gather, probabilistic)</option>
                    <option value="18">Stochastic Jinc Scatter (scatter, probabilistic)</option>
                    <option value="19">Stochastic Jinc Scatter Normalized (scatter, normalized dest)</option>
                    <option value="5">Lanczos3 Scatter (experimental)</option>
                    <option value="6">Sinc Scatter (experimental, SLOW)</option>
                </select>
            </div>

            <!-- Dither options hidden - using good defaults (Mixed + OKLab color-aware) -->
            <div class="option-row" style="display: none;">
                <label>Dither Mode:</label>
                <select id="dither-mode">
                    <option value="4" selected>Mixed (reduces patterns)</option>
                </select>
            </div>
            <input type="hidden" id="perceptual-toggle" value="1">
            <input type="hidden" id="perceptual-space" value="1">

            <div class="option-row">
                <label>
                    <input type="checkbox" id="show-comparison" checked>
                    Show sRGB comparison
                </label>
            </div>
        </div>

        <div class="button-row">
            <button id="process-btn" disabled>Resize Image</button>
            <button id="download-btn" class="button-secondary" disabled>Download PNG</button>
        </div>

        <div class="loading" id="loading">
            <div class="sparkle-container">
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
            </div>
            <div>Processing... <span id="progress-text">0%</span></div>
            <div style="width: 200px; height: 8px; background: #ddd; border-radius: 4px; margin-top: 10px; display: inline-block;">
                <div id="progress-bar" style="width: 0%; height: 100%; background: #3498db; border-radius: 4px; transition: width 0.1s;"></div>
            </div>
        </div>
    </div>

    <div class="container" id="output-section">
        <h3>Result</h3>
        <div class="output-container">
            <div id="single-output" style="display: none;">
                <div class="alpha-checkerboard" style="display: inline-block;">
                    <canvas id="output-canvas"></canvas>
                </div>
            </div>
            <div id="comparison-output" class="comparison-container" style="display: none;">
                <div class="comparison-box">
                    <h4>Linear RGB (correct)</h4>
                    <div class="alpha-checkerboard">
                        <canvas id="linear-canvas"></canvas>
                    </div>
                </div>
                <div class="comparison-box">
                    <h4>sRGB (incorrect)</h4>
                    <div class="alpha-checkerboard">
                        <canvas id="srgb-canvas"></canvas>
                    </div>
                </div>
            </div>
            <p class="output-info" id="output-info"></p>
        </div>

        <div class="cli-command-section" id="cli-command-section" style="margin-top: 20px;">
            <h4 style="margin-bottom: 10px; color: #555;">CLI command</h4>
            <pre class="cli-command" id="cli-command" style="background: #1e1e1e; color: #9cdcfe; padding: 15px; border-radius: 8px; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 13px; overflow-x: auto; white-space: pre-wrap; word-break: break-all;"></pre>
        </div>
    </div>

    <script>
        let worker = null;
        let workerReady = false;
        let inputFileBytes = null;      // Raw file bytes for precise WASM decoding
        let originalWidth = 0;
        let originalHeight = 0;
        let aspectRatio = 1;
        let updatingSize = false;
        let primaryDimension = 'width'; // 'width' or 'height' - which dimension is authoritative
        let lastLinearResult = null;
        let lastOutputWidth = 0;
        let lastOutputHeight = 0;
        let lastHasAlpha = false;
        let processTimestamp = null; // Timestamp when processing started

        // Scale mode constants (must match Rust enum)
        const SCALE_MODE_INDEPENDENT = 0;
        const SCALE_MODE_UNIFORM_WIDTH = 1;
        const SCALE_MODE_UNIFORM_HEIGHT = 2;

        // Pending operation state for comparison mode
        let pendingComparison = null;

        // Generate download filename with timestamp
        function generateDownloadFilename(width, height, format, ext) {
            const ts = processTimestamp || Date.now();
            return `cra_${ts}_${width}x${height}_${format}.${ext}`;
        }

        function initWorker() {
            worker = new Worker('./resize-worker.js', { type: 'module' });

            worker.onmessage = function(e) {
                const { type, ...data } = e.data;

                switch (type) {
                    case 'ready':
                        console.log('[resize] Worker ready, inputFileBytes:', !!inputFileBytes);
                        workerReady = true;
                        document.getElementById('init-overlay').classList.add('hidden');
                        updateProcessButtonState();
                        break;

                    case 'progress':
                        updateProgressDisplay(data.percent);
                        break;

                    case 'complete':
                        handleResizeComplete(data);
                        break;

                    case 'error':
                        handleResizeError(data.message);
                        break;

                    case 'png-encoded':
                        handlePngEncoded(data);
                        break;
                }
            };

            worker.onerror = function(e) {
                console.error('Worker error:', e);
                handleResizeError('Worker error: ' + e.message);
            };

            // Initialize the worker
            worker.postMessage({ type: 'init' });
        }

        function updateProgressDisplay(percent) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');

            // If in comparison mode, scale progress appropriately
            if (pendingComparison) {
                if (pendingComparison.stage === 'linear') {
                    percent = Math.round(percent / 2);
                } else {
                    percent = 50 + Math.round(percent / 2);
                }
            }

            progressBar.style.width = percent + '%';
            progressText.textContent = percent + '%';
        }

        function handleResizeComplete(data) {
            const { outputData, width, height, hasAlpha } = data;
            const imageData = new ImageData(new Uint8ClampedArray(outputData), width, height);

            if (pendingComparison) {
                if (pendingComparison.stage === 'linear') {
                    // Store linear result and start sRGB resize
                    pendingComparison.linearResult = imageData;
                    pendingComparison.stage = 'srgb';

                    // Store linear result for download (before sRGB overwrites)
                    lastLinearResult = outputData;
                    lastOutputWidth = width;
                    lastOutputHeight = height;
                    lastHasAlpha = hasAlpha || false;

                    // Start sRGB (bad) resize - use simple Floyd-Steinberg without color-awareness
                    worker.postMessage({
                        type: 'resize-srgb',
                        ...pendingComparison.params,
                        ditherMode: 0,        // Floyd-Steinberg standard (not mixed)
                        ditherTechnique: 1    // PerChannel (not ColorAware)
                    });
                } else {
                    // Both done - display comparison
                    displayComparison(pendingComparison.linearResult, imageData, width, height);
                    pendingComparison = null;
                    finishProcessing();
                }
            } else {
                // Single result mode
                displaySingleResult(imageData, width, height);
                finishProcessing();

                // Store for download
                lastLinearResult = outputData;
                lastOutputWidth = width;
                lastOutputHeight = height;
                lastHasAlpha = hasAlpha || false;
            }
        }

        function handleResizeError(message) {
            console.error('Resize failed:', message);
            document.getElementById('error-message').textContent = 'Processing failed: ' + message;
            document.getElementById('error-message').classList.add('visible');
            document.getElementById('loading').classList.remove('active');
            pendingComparison = null;
        }

        function displaySingleResult(imageData, width, height) {
            document.getElementById('single-output').style.display = 'block';
            document.getElementById('comparison-output').style.display = 'none';

            const canvas = document.getElementById('output-canvas');
            canvas.width = width;
            canvas.height = height;
            canvas.getContext('2d').putImageData(imageData, 0, 0);

            document.getElementById('output-info').textContent =
                `${originalWidth}x${originalHeight} → ${width}x${height}`;
        }

        function displayComparison(linearImageData, srgbImageData, width, height) {
            document.getElementById('single-output').style.display = 'none';
            document.getElementById('comparison-output').style.display = 'grid';

            const linearCanvas = document.getElementById('linear-canvas');
            linearCanvas.width = width;
            linearCanvas.height = height;
            linearCanvas.getContext('2d').putImageData(linearImageData, 0, 0);

            const srgbCanvas = document.getElementById('srgb-canvas');
            srgbCanvas.width = width;
            srgbCanvas.height = height;
            srgbCanvas.getContext('2d').putImageData(srgbImageData, 0, 0);

            document.getElementById('output-info').textContent =
                `${originalWidth}x${originalHeight} → ${width}x${height}`;
        }

        function finishProcessing() {
            document.getElementById('loading').classList.remove('active');
            document.getElementById('output-section').style.display = 'block';
            document.getElementById('download-btn').disabled = false;

            // Update CLI command
            const cliCommand = generateCliCommand();
            document.getElementById('cli-command').textContent = cliCommand;
        }

        // Generate CLI command based on current settings
        function generateCliCommand() {
            const interpolation = parseInt(document.getElementById('interpolation').value);
            const ditherMode = parseInt(document.getElementById('dither-mode').value);
            const isPerceptual = document.getElementById('perceptual-toggle').value === '1';
            const perceptualSpace = parseInt(document.getElementById('perceptual-space').value);

            // Map interpolation to CLI names
            const interpolationMap = { 0: 'bilinear', 1: 'lanczos', 2: 'mitchell', 3: 'catmull-rom', 4: 'sinc', 5: 'lanczos-scatter', 6: 'sinc-scatter', 7: 'lanczos2', 8: 'ewa-sinc-lanczos2', 9: 'ewa-sinc-lanczos3', 12: 'ewa-lanczos2', 13: 'ewa-lanczos3', 14: 'ewa-mitchell', 15: 'ewa-catmull-rom', 16: 'jinc', 17: 'stochastic-jinc', 18: 'stochastic-jinc-scatter', 19: 'stochastic-jinc-scatter-normalized', 20: 'box', 21: 'ewa-lanczos3-sharp', 22: 'ewa-lanczos4-sharpest' };

            // Map dither mode values to CLI names
            const modeMap = {
                0: 'fs-standard',
                1: 'fs-serpentine',
                2: 'jjn-standard',
                3: 'jjn-serpentine',
                4: 'mixed-standard',
                5: 'mixed-serpentine',
                6: 'mixed-random',
                7: 'none'
            };

            // Map perceptual space values to CLI names
            const spaceMap = {
                0: 'lab-cie76',
                1: 'oklab',
                2: 'lab-cie94',
                3: 'lab-ciede2000',
                4: 'linear-rgb',
                5: 'y-cb-cr'
            };

            // Use cra tool for resize (--histogram defaults to none when no --ref)
            let cmd = 'cra -i input.png -o output.png';

            // Add resize dimensions
            if (primaryDimension === 'width') {
                cmd += ` --width ${lastOutputWidth}`;
            } else {
                cmd += ` --height ${lastOutputHeight}`;
            }

            // Add scale method (only if not default ewa-lanczos3)
            if (interpolation !== 13) {
                cmd += ` --scale-method ${interpolationMap[interpolation]}`;
            }

            // Add dither mode (only if not default mixed-standard)
            if (ditherMode !== 4) {
                cmd += ` --output-dither ${modeMap[ditherMode]}`;
            }

            // Add colorspace if perceptual and not default oklab
            if (isPerceptual && perceptualSpace !== 1) {
                cmd += ` --output-distance-space ${spaceMap[perceptualSpace]}`;
            }

            // Add --no-colorspace-aware-output if not using perceptual
            if (!isPerceptual) {
                cmd += ' --no-colorspace-aware-output';
            }

            return cmd;
        }

        // Load image file as ArrayBuffer (for precise WASM decoding in worker)
        function loadImageBytes(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        // Load image for preview and dimensions (uses Canvas for UI only)
        function loadImagePreview(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        resolve({
                            dataUrl: e.target.result,
                            width: img.width,
                            height: img.height
                        });
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Update size fields based on aspect ratio
        function updateSizeFromWidth() {
            if (updatingSize || !originalWidth) return;
            updatingSize = true;
            primaryDimension = 'width';
            const width = parseInt(document.getElementById('target-width').value) || 1;
            const height = Math.round(width / aspectRatio);
            document.getElementById('target-height').value = height;
            updatingSize = false;
            updateDimensionStyling();
        }

        function updateSizeFromHeight() {
            if (updatingSize || !originalHeight) return;
            updatingSize = true;
            primaryDimension = 'height';
            const height = parseInt(document.getElementById('target-height').value) || 1;
            const width = Math.round(height * aspectRatio);
            document.getElementById('target-width').value = width;
            updatingSize = false;
            updateDimensionStyling();
        }

        // Update visual styling to show which dimension is primary vs secondary
        function updateDimensionStyling() {
            const widthInput = document.getElementById('target-width');
            const heightInput = document.getElementById('target-height');
            if (primaryDimension === 'width') {
                widthInput.classList.remove('secondary-dimension');
                heightInput.classList.add('secondary-dimension');
            } else {
                heightInput.classList.remove('secondary-dimension');
                widthInput.classList.add('secondary-dimension');
            }
        }

        // Update process button state based on worker readiness and image loaded
        function updateProcessButtonState() {
            const shouldEnable = workerReady && inputFileBytes;
            console.log('[resize] updateProcessButtonState: workerReady=', workerReady, 'inputFileBytes=', !!inputFileBytes, 'shouldEnable=', shouldEnable);
            document.getElementById('process-btn').disabled = !shouldEnable;
        }

        function calculateOutputDimensions() {
            const width = parseInt(document.getElementById('target-width').value) || 256;
            const height = parseInt(document.getElementById('target-height').value) || 256;
            return { width, height };
        }

        function processImage() {
            if (!inputFileBytes || !workerReady) return;

            // Store timestamp when processing starts
            processTimestamp = Date.now();

            const loading = document.getElementById('loading');
            const errorMsg = document.getElementById('error-message');
            const outputSection = document.getElementById('output-section');

            loading.classList.add('active');
            errorMsg.classList.remove('visible');
            outputSection.style.display = 'none';

            // Reset progress display
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            progressBar.style.width = '0%';
            progressText.textContent = '0%';

            const { width: dstW, height: dstH } = calculateOutputDimensions();
            const interpolation = parseInt(document.getElementById('interpolation').value);
            const ditherMode = parseInt(document.getElementById('dither-mode').value);
            const showComparison = document.getElementById('show-comparison').checked;
            const isPerceptual = document.getElementById('perceptual-toggle').value === '1';
            const perceptualSpace = parseInt(document.getElementById('perceptual-space').value);

            // Dither technique: 1 = PerChannel, 2 = ColorAware
            const ditherTechnique = isPerceptual ? 2 : 1;

            // Use the primary dimension to determine scale mode
            const scaleMode = primaryDimension === 'width'
                ? SCALE_MODE_UNIFORM_WIDTH
                : SCALE_MODE_UNIFORM_HEIGHT;

            const params = {
                fileBytes: inputFileBytes,  // Send raw file bytes for precise WASM decoding
                dstWidth: dstW,
                dstHeight: dstH,
                interpolation,
                scaleMode,
                ditherMode,
                ditherTechnique,
                perceptualSpace
            };

            if (showComparison) {
                // Set up comparison mode - will do linear first, then sRGB
                pendingComparison = {
                    stage: 'linear',
                    params,
                    linearResult: null
                };
            } else {
                pendingComparison = null;
            }

            // Start linear resize (correct way)
            worker.postMessage({
                type: 'resize',
                ...params
            });
        }

        // Handle PNG encoding result from worker
        function handlePngEncoded(data) {
            const { pngBytes } = data;
            const blob = new Blob([pngBytes], { type: 'image/png' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            const format = lastHasAlpha ? 'RGBA8' : 'RGB8';
            link.download = generateDownloadFilename(lastOutputWidth, lastOutputHeight, format, 'png');
            link.href = url;
            link.click();

            // Clean up
            URL.revokeObjectURL(url);
        }

        function downloadResult() {
            if (!lastLinearResult) return;

            // Send to worker for proper PNG encoding (RGB or RGBA based on input)
            worker.postMessage({
                type: 'encode-png',
                rgbaData: lastLinearResult,
                width: lastOutputWidth,
                height: lastOutputHeight,
                hasAlpha: lastHasAlpha
            });
        }

        // Event handlers
        document.getElementById('upload-box').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });

        // Core file handling logic - called from both file input and drag-drop
        async function handleFile(file) {
            console.log('[resize] handleFile called, file:', file?.name, 'workerReady:', workerReady);
            if (!file) return;

            try {
                // Load file bytes for precise WASM decoding in worker
                const fileBytes = await loadImageBytes(file);
                inputFileBytes = fileBytes;
                console.log('[resize] inputFileBytes set, size:', fileBytes.byteLength);

                // Load preview image for UI (dimensions and display)
                const { dataUrl, width, height } = await loadImagePreview(file);
                originalWidth = width;
                originalHeight = height;
                aspectRatio = width / height;

                // Set initial target size (fit to 256 on longest side)
                // For landscape/square, width is primary; for portrait, height is primary
                const maxDim = 256;
                if (aspectRatio >= 1) {
                    primaryDimension = 'width';
                    document.getElementById('target-width').value = maxDim;
                    document.getElementById('target-height').value = Math.round(maxDim / aspectRatio);
                } else {
                    primaryDimension = 'height';
                    document.getElementById('target-height').value = maxDim;
                    document.getElementById('target-width').value = Math.round(maxDim * aspectRatio);
                }
                updateDimensionStyling();

                const box = document.getElementById('upload-box');
                box.classList.add('has-image');

                box.innerHTML = `
                    <div class="alpha-checkerboard">
                        <img id="input-preview" src="${dataUrl}" alt="Preview">
                    </div>
                    <label>Image loaded: ${width}x${height}</label>
                    <p class="hint">Click to change image</p>
                    <input type="file" id="file-input" accept="image/*,.safetensors">
                `;

                // Re-attach event listener to new input element
                document.getElementById('file-input').addEventListener('change', (e) => handleFile(e.target.files[0]));

                updateProcessButtonState();
                document.getElementById('error-message').classList.remove('visible');
            } catch (err) {
                document.getElementById('error-message').textContent = 'Failed to load image: ' + err.message;
                document.getElementById('error-message').classList.add('visible');
            }
        }

        document.getElementById('file-input').addEventListener('change', (e) => handleFile(e.target.files[0]));

        // Drag and drop
        document.getElementById('upload-box').addEventListener('dragover', (e) => {
            e.preventDefault();
            e.currentTarget.style.borderColor = '#3498db';
        });

        document.getElementById('upload-box').addEventListener('dragleave', (e) => {
            e.currentTarget.style.borderColor = '';
        });

        document.getElementById('upload-box').addEventListener('drop', (e) => {
            e.preventDefault();
            e.currentTarget.style.borderColor = '';
            const file = e.dataTransfer.files[0];
            console.log('[resize] drop event, file:', file?.name, 'type:', file?.type);
            if (file && (file.type.startsWith('image/') || file.name.endsWith('.safetensors') || !file.type)) {
                handleFile(file);
            }
        });

        // Size input handlers (maintain aspect ratio)
        document.getElementById('target-width').addEventListener('input', updateSizeFromWidth);
        document.getElementById('target-height').addEventListener('input', updateSizeFromHeight);

        // Preset buttons - set width and auto-calculate height from aspect ratio
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.getElementById('target-width').value = btn.dataset.w;
                updateSizeFromWidth();
            });
        });

        document.getElementById('process-btn').addEventListener('click', processImage);
        document.getElementById('download-btn').addEventListener('click', downloadResult);

        // Initialize
        initWorker();
    </script>
</body>
</html>
