<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dithering Demo</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
            color: #333;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }

        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .upload-box {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
        }

        .upload-box:hover {
            border-color: #3498db;
            background: #f8f9fa;
        }

        .upload-box.has-image {
            border-style: solid;
            border-color: #27ae60;
        }

        .upload-box img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 4px;
        }

        .upload-box label {
            font-weight: 600;
            color: #555;
            margin-bottom: 10px;
            display: block;
        }

        .upload-box .hint {
            color: #888;
            font-size: 14px;
        }

        input[type="file"] {
            display: none;
        }

        .options-section {
            margin-bottom: 30px;
        }

        .options-section h3 {
            margin-bottom: 15px;
            color: #555;
        }

        .option-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .option-row label {
            font-weight: 600;
            min-width: 120px;
            color: #555;
        }

        .option-row select {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        .channel-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .channel-options {
                grid-template-columns: 1fr;
            }
        }

        .channel-box {
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .channel-box.red { background: #ffebee; border: 2px solid #e57373; }
        .channel-box.green { background: #e8f5e9; border: 2px solid #81c784; }
        .channel-box.blue { background: #e3f2fd; border: 2px solid #64b5f6; }

        .channel-box h4 {
            margin: 0 0 10px 0;
        }

        .channel-box.red h4 { color: #c62828; }
        .channel-box.green h4 { color: #2e7d32; }
        .channel-box.blue h4 { color: #1565c0; }

        .channel-box input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }

        .bit-value {
            font-size: 14px;
            color: #555;
            font-weight: 500;
        }

        .toggle-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .toggle-row > span {
            font-weight: 600;
            color: #555;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #555;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .channel-box.gray {
            background: #f5f5f5;
            border: 2px solid #888;
        }

        .channel-box.gray h4 {
            color: #555;
        }

        .grayscale-options {
            display: none;
        }

        .grayscale-options.active {
            display: block;
        }

        .rgb-options.hidden {
            display: none;
        }

        .seed-options {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .seed-options.visible {
            display: block;
        }

        .perceptual-options {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #f3e5f5;
            border-radius: 8px;
            border: 1px solid #ce93d8;
        }

        .perceptual-options.visible {
            display: block;
        }

        .perceptual-options label {
            font-weight: 600;
            color: #555;
            margin-right: 10px;
        }

        .perceptual-options select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .perceptual-options .perceptual-hint {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
        }

        .option-row.hidden {
            display: none;
        }

        .seed-options label {
            font-weight: 600;
            color: #555;
            margin-right: 10px;
        }

        .seed-options input[type="number"] {
            width: 120px;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .seed-options .seed-hint {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
        }

        .stride-options {
            margin-top: 15px;
            padding: 15px;
            background: #e8f4fd;
            border-radius: 8px;
            border: 1px solid #90caf9;
        }

        .stride-options label {
            font-weight: 600;
            color: #555;
            margin-right: 10px;
        }

        .stride-options select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .stride-options .stride-hint {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
        }

        .stride-options .stride-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .stride-options .stride-select-group,
        .stride-options .stride-fill-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .scale-options {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .scale-options.visible {
            display: block;
        }

        .scale-options .size-inputs {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .scale-options .size-inputs label {
            font-weight: 600;
            color: #555;
        }

        .scale-options .size-inputs input[type="number"] {
            width: 80px;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .scale-options .size-inputs span {
            color: #888;
        }

        .scale-options .scale-hint {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
        }

        .upscale-options {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #f0f8ff;
            border-radius: 8px;
            border: 1px solid #64b5f6;
        }

        .upscale-options.visible {
            display: block;
        }

        .upscale-options label {
            font-weight: 600;
            color: #555;
            margin-right: 10px;
        }

        .upscale-options input[type="number"] {
            width: 60px;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .upscale-options .upscale-hint {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
        }

        .process-btn {
            width: 100%;
            padding: 15px 30px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .process-btn:hover:not(:disabled) {
            background: #2980b9;
        }

        .process-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .output-section {
            text-align: center;
        }

        .output-section h3 {
            margin-bottom: 20px;
            color: #555;
        }

        .compare-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .compare-section {
                grid-template-columns: 1fr;
            }
        }

        .compare-box {
            text-align: center;
        }

        .compare-box img,
        .compare-box linear-img {
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .compare-box img {
            image-rendering: pixelated;
        }

        .compare-box p {
            margin-top: 10px;
            font-weight: 600;
            color: #555;
        }

        .download-btn {
            display: inline-block;
            margin-top: 15px;
            padding: 10px 25px;
            background: #27ae60;
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: background 0.3s ease;
            cursor: pointer;
            border: none;
            font-size: 14px;
        }

        .download-btn:hover {
            background: #219a52;
        }

        .download-section {
            margin-top: 25px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .download-section h4 {
            margin: 0 0 15px 0;
            color: #555;
        }

        .download-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .download-btn.secondary {
            background: #3498db;
        }

        .download-btn.secondary:hover {
            background: #2980b9;
        }

        .download-btn.tertiary {
            background: #9b59b6;
        }

        .download-btn.tertiary:hover {
            background: #8e44ad;
        }

        .download-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .format-info {
            font-size: 12px;
            color: #888;
            margin-top: 10px;
        }

        .channel-downloads {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e0e0e0;
        }

        .channel-downloads h5 {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 13px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .init-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .init-overlay.hidden {
            display: none;
        }

        .error-message {
            background: #fee;
            border: 1px solid #fcc;
            border-radius: 8px;
            padding: 15px;
            color: #c00;
            margin-top: 15px;
            display: none;
        }

        .error-message.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div class="init-overlay" id="init-overlay">
        <div class="spinner"></div>
        <h2>Loading Dither Demo...</h2>
        <p>Initializing WASM module...</p>
    </div>

    <h1>Dithering Demo</h1>
    <p class="subtitle">Error diffusion dithering with configurable bit depth per channel</p>

    <div class="container">
        <div class="upload-box" id="input-upload" onclick="document.getElementById('input-file').click()">
            <label>Input Image</label>
            <p class="hint">Click to upload or drag and drop</p>
            <input type="file" id="input-file" accept="image/*">
            <img id="input-preview" style="display: none;">
        </div>

        <div class="options-section">
            <h3>Dither Settings</h3>

            <div class="toggle-row">
                <span>Color Space Aware:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="perceptual-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="perceptual-options visible" id="perceptual-options">
                <label for="perceptual-space">Distance Metric:</label>
                <select id="perceptual-space">
                    <option value="1" selected>* OKLab</option>
                    <option value="3">CIELAB (CIEDE2000)</option>
                    <option value="2">* CIELAB (CIE94)</option>
                    <option value="0">CIELAB (CIE76)</option>
                    <option value="4">Linear RGB (not recommended)</option>
                    <option value="5">Y'CbCr (not recommended)</option>
                </select>
                <p class="perceptual-hint">Uses perceptual distance for candidate selection with linear error diffusion. For RGB, processes channels jointly. For grayscale: CIE76=CIE94 (simple ΔL²), CIEDE2000 uses lightness-dependent weighting, OKLab uses different L curve.</p>
            </div>

            <div class="option-row" id="dither-mode-row">
                <label for="dither-mode">Dither Mode:</label>
                <select id="dither-mode">
                    <option value="0">* Floyd-Steinberg (Standard)</option>
                    <option value="1">Floyd-Steinberg (Serpentine)</option>
                    <option value="2">* Jarvis-Judice-Ninke (Standard)</option>
                    <option value="3">Jarvis-Judice-Ninke (Serpentine)</option>
                    <option value="4" selected>* Mixed (Standard)</option>
                    <option value="5">Mixed (Serpentine)</option>
                    <option value="6">Mixed (Random Direction)</option>
                </select>
            </div>

            <div class="seed-options visible" id="seed-options">
                <label for="seed-input">Seed:</label>
                <input type="number" id="seed-input" value="12345" min="0" max="4294967295">
                <p class="seed-hint">Controls random kernel selection in Mixed modes. Each channel uses a different derived seed.</p>
            </div>

            <div class="stride-options">
                <div class="stride-row">
                    <div class="stride-select-group">
                        <label for="stride-select">Binary Row Stride:</label>
                        <select id="stride-select">
                            <option value="1" selected>1 byte (no padding)</option>
                            <option value="2">2 bytes</option>
                            <option value="4">4 bytes</option>
                            <option value="8">8 bytes</option>
                            <option value="16">16 bytes</option>
                            <option value="32">32 bytes</option>
                            <option value="64">64 bytes</option>
                            <option value="128">128 bytes</option>
                        </select>
                    </div>
                    <div class="stride-fill-group">
                        <label for="stride-fill-select">Padding Fill:</label>
                        <select id="stride-fill-select">
                            <option value="0" selected>Black (zeros)</option>
                            <option value="1">Repeat last pixel</option>
                        </select>
                    </div>
                </div>
                <p class="stride-hint">Row stride applies to row-aligned output. Padding fill affects both row padding and RGB666 partial groups (4-pixel boundaries).</p>
            </div>

            <div class="toggle-row">
                <span>Grayscale:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="grayscale-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="toggle-row">
                <span>Downscale:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="downscale-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="scale-options" id="scale-options">
                <div class="size-inputs">
                    <label for="scale-width">Width:</label>
                    <input type="number" id="scale-width" value="128" min="1" max="4096">
                    <span>x</span>
                    <label for="scale-height">Height:</label>
                    <input type="number" id="scale-height" value="128" min="1" max="4096">
                </div>
                <div class="size-inputs" style="margin-top: 10px;">
                    <label for="scale-method">Method:</label>
                    <select id="scale-method">
                        <option value="1" selected>Lanczos (high quality)</option>
                        <option value="0">Bilinear (fast)</option>
                    </select>
                </div>
                <p class="scale-hint">Rescaling is performed in linear RGB space for correct color blending.</p>
            </div>

            <div class="toggle-row">
                <span>Upscale for viewing:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="upscale-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="upscale-options" id="upscale-options">
                <label for="upscale-factor">Scale factor:</label>
                <input type="number" id="upscale-factor" value="4" min="1" max="16">
                <span>x</span>
                <p class="upscale-hint">Integer upscaling with nearest neighbor for pixel-perfect viewing.</p>
            </div>

            <div class="channel-options rgb-options" id="rgb-options">
                <div class="channel-box red">
                    <h4>Red Channel</h4>
                    <input type="range" id="bits-r" min="1" max="8" value="3">
                    <p class="bit-value" id="bits-r-label">3 bits (8 levels)</p>
                </div>
                <div class="channel-box green">
                    <h4>Green Channel</h4>
                    <input type="range" id="bits-g" min="1" max="8" value="3">
                    <p class="bit-value" id="bits-g-label">3 bits (8 levels)</p>
                </div>
                <div class="channel-box blue">
                    <h4>Blue Channel</h4>
                    <input type="range" id="bits-b" min="1" max="8" value="2">
                    <p class="bit-value" id="bits-b-label">2 bits (4 levels)</p>
                </div>
            </div>

            <div class="grayscale-options" id="grayscale-options">
                <div class="channel-box gray">
                    <h4>Grayscale</h4>
                    <input type="range" id="bits-gray" min="1" max="8" value="4">
                    <p class="bit-value" id="bits-gray-label">4 bits (16 levels)</p>
                </div>
            </div>
        </div>

        <button class="process-btn" id="process-btn" disabled>Apply Dithering</button>

        <div class="error-message" id="error-message"></div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Processing image...</p>
        </div>
    </div>

    <div class="container output-section" id="output-section" style="display: none;">
        <h3>Result</h3>
        <div class="compare-section">
            <div class="compare-box">
                <img id="compare-input">
                <p>Original</p>
            </div>
            <div class="compare-box">
                <linear-img id="compare-output" method="lanczos"></linear-img>
                <p>Dithered</p>
            </div>
        </div>

        <div class="download-section">
            <h4>Downloads</h4>
            <div class="download-row">
                <a class="download-btn" id="download-btn" download="dithered.png">PNG Image</a>
                <button class="download-btn secondary" id="download-raw-btn" disabled>Raw (packed)</button>
                <button class="download-btn secondary" id="download-raw-r-btn" disabled>Raw (row-aligned)</button>
                <button class="download-btn tertiary" id="download-meta-btn">Metadata JSON</button>
            </div>
            <p class="format-info" id="format-info">Format: RGB332 (8 bits/pixel) - raw download available</p>

            <div class="channel-downloads" id="channel-downloads">
                <h5>Per-Channel Raw</h5>
                <div class="download-row">
                    <button class="download-btn secondary" id="download-r-btn" disabled>R Channel</button>
                    <button class="download-btn secondary" id="download-g-btn" disabled>G Channel</button>
                    <button class="download-btn secondary" id="download-b-btn" disabled>B Channel</button>
                </div>
            </div>
        </div>

        <div class="cli-command-section" id="cli-command-section" style="margin-top: 20px;">
            <h4 style="margin-bottom: 10px; color: #555;">CLI command</h4>
            <pre class="cli-command" id="cli-command" style="background: #1e1e1e; color: #9cdcfe; padding: 15px; border-radius: 8px; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 13px; overflow-x: auto; white-space: pre-wrap; word-break: break-all;"></pre>
        </div>
    </div>

    <script type="module">
        import './linear-img.js';
        import init, {
            dither_output_wasm,
            dither_with_mode_wasm,
            colorspace_aware_dither_gray_with_mode_wasm,
            // Binary encoding functions
            format_supports_binary_wasm,
            format_total_bits_wasm,
            encode_rgb_packed_wasm,
            encode_rgb_row_aligned_wasm,
            encode_rgb_row_aligned_stride_wasm,
            encode_gray_packed_wasm,
            encode_gray_row_aligned_wasm,
            encode_gray_row_aligned_stride_wasm,
            encode_channel_packed_wasm,
            encode_channel_row_aligned_stride_wasm,
            // Precise image decoding (preserves 16-bit, extracts ICC)
            decode_image_wasm,           // Returns f32 0-1 (for linear processing path)
            decode_image_srgb_255_wasm,  // Returns f32 0-255 (for sRGB-direct path)
            // ICC profile handling
            extract_icc_profile_wasm,
            is_icc_profile_srgb_wasm,
            transform_icc_to_linear_srgb_wasm,
            // Atomic color space conversion functions
            denormalize_f32_wasm,
            srgb_to_linear_f32_wasm,
            linear_to_srgb_f32_wasm,
            linear_rgb_to_grayscale_wasm,
            linear_gray_to_srgb_f32_wasm,
            denormalize_gray_f32_wasm,
            // Atomic rescaling functions (linear space)
            rescale_linear_rgb_wasm,
            rescale_linear_gray_wasm,
            calculate_dimensions_wasm
        } from './wasm_cra/cra_wasm.js';

        // Get seeds from base seed (different for each channel)
        function getSeeds() {
            const baseSeed = parseInt(document.getElementById('seed-input').value) || 0;
            return {
                r: baseSeed,
                g: baseSeed + 55555,
                b: baseSeed + 11111
            };
        }

        // Decode image to f32 0-1 (for linear processing path)
        function decodeToNormalized(fileBytes) {
            const result = decode_image_wasm(new Uint8Array(fileBytes));
            return {
                width: result[0],
                height: result[1],
                hasIcc: result[2] > 0.5,
                is16bit: result[3] > 0.5,
                pixels: result.slice(4)
            };
        }

        // Decode image directly to f32 0-255 (for sRGB-direct path, no intermediate)
        function decodeToSrgb255(fileBytes) {
            const result = decode_image_srgb_255_wasm(new Uint8Array(fileBytes));
            return {
                width: result[0],
                height: result[1],
                hasIcc: result[2] > 0.5,
                is16bit: result[3] > 0.5,
                pixels: result.slice(4)
            };
        }

        // Check if image has non-sRGB ICC profile (for auto color management)
        function checkNonSrgbIcc(fileBytes, hasIcc) {
            if (!hasIcc) return false;
            const iccProfile = extract_icc_profile_wasm(new Uint8Array(fileBytes));
            return iccProfile.length > 0 && !is_icc_profile_srgb_wasm(iccProfile);
        }

        // Get ICC profile for transform (call only if checkNonSrgbIcc returned true)
        function getIccProfile(fileBytes) {
            return extract_icc_profile_wasm(new Uint8Array(fileBytes));
        }

        let wasmReady = false;
        let inputFileBytes = null;      // Raw file bytes (decoded on demand based on processing mode)
        let inputHasNonSrgbIcc = false; // True if image has ICC profile that differs from sRGB
        let inputWidth = 0;
        let inputHeight = 0;
        let originalWidth = 0;
        let originalHeight = 0;
        let aspectRatio = 1;
        let updatingSize = false; // Prevent recursive updates
        let primaryDimension = 'width'; // 'width' or 'height' - which dimension is authoritative

        // Scale mode constants (must match Rust enum)
        const SCALE_MODE_INDEPENDENT = 0;
        const SCALE_MODE_UNIFORM_WIDTH = 1;
        const SCALE_MODE_UNIFORM_HEIGHT = 2;

        // Store last dithered result for binary downloads
        let lastDitherResult = null;

        // Initialize WASM
        async function initWasm() {
            try {
                await init();
                wasmReady = true;
                document.getElementById('init-overlay').classList.add('hidden');
                updateProcessButton();
            } catch (err) {
                console.error('Failed to initialize WASM:', err);
                document.getElementById('init-overlay').innerHTML = `
                    <h2>Error Loading WASM</h2>
                    <p style="color: #c00;">${err.message}</p>
                `;
            }
        }

        // Update process button state
        function updateProcessButton() {
            const btn = document.getElementById('process-btn');
            btn.disabled = !wasmReady || !inputFileBytes;
        }

        // Load image file as ArrayBuffer (for precise WASM decoding)
        function loadImageBytes(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        // Create preview image from file (for display only)
        function createPreview(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Note: rescaleImageData removed - now using atomic pipeline in processImage

        // Upscale image data using nearest neighbor
        function upscaleNearestNeighbor(imageData, srcWidth, srcHeight, factor) {
            const dstWidth = srcWidth * factor;
            const dstHeight = srcHeight * factor;
            const srcData = imageData.data;
            const dstData = new Uint8ClampedArray(dstWidth * dstHeight * 4);

            for (let y = 0; y < dstHeight; y++) {
                const srcY = Math.floor(y / factor);
                for (let x = 0; x < dstWidth; x++) {
                    const srcX = Math.floor(x / factor);
                    const srcIdx = (srcY * srcWidth + srcX) * 4;
                    const dstIdx = (y * dstWidth + x) * 4;
                    dstData[dstIdx] = srcData[srcIdx];
                    dstData[dstIdx + 1] = srcData[srcIdx + 1];
                    dstData[dstIdx + 2] = srcData[srcIdx + 2];
                    dstData[dstIdx + 3] = srcData[srcIdx + 3];
                }
            }

            return new ImageData(dstData, dstWidth, dstHeight);
        }

        // Update size fields based on aspect ratio
        function updateSizeFromWidth() {
            if (updatingSize || !originalWidth) return;
            updatingSize = true;
            primaryDimension = 'width';
            const width = parseInt(document.getElementById('scale-width').value) || 1;
            const height = Math.round(width / aspectRatio);
            document.getElementById('scale-height').value = height;
            updatingSize = false;
        }

        function updateSizeFromHeight() {
            if (updatingSize || !originalHeight) return;
            updatingSize = true;
            primaryDimension = 'height';
            const height = parseInt(document.getElementById('scale-height').value) || 1;
            const width = Math.round(height * aspectRatio);
            document.getElementById('scale-width').value = width;
            updatingSize = false;
        }

        // Dither a single channel
        function ditherChannel(channelData, width, height, mode, seed, bits) {
            // Convert to Float32Array (expected by WASM)
            const floatData = new Float32Array(channelData.length);
            for (let i = 0; i < channelData.length; i++) {
                floatData[i] = channelData[i];
            }

            // Call WASM dither function
            return dither_with_mode_wasm(floatData, width, height, mode, seed, bits);
        }

        // Process the image using atomic pipeline
        // Pipeline decisions:
        // - RGB without rescale: decode to f32 0-255 → dither directly (no intermediate)
        // - RGB with rescale: decode to f32 0-1 → linear → rescale → sRGB → denormalize → dither
        // - Grayscale: decode to f32 0-1 → linear → [rescale] → grayscale → sRGB → denormalize → dither
        async function processImage() {
            if (!inputFileBytes) return;

            const loading = document.getElementById('loading');
            const errorMsg = document.getElementById('error-message');
            const outputSection = document.getElementById('output-section');

            loading.classList.add('active');
            errorMsg.classList.remove('visible');
            outputSection.style.display = 'none';

            try {
                const mode = parseInt(document.getElementById('dither-mode').value);
                const isGrayscale = document.getElementById('grayscale-toggle').checked;
                const doDownscale = document.getElementById('downscale-toggle').checked;
                const doUpscale = document.getElementById('upscale-toggle').checked;
                const upscaleFactor = parseInt(document.getElementById('upscale-factor').value) || 1;
                const scaleMethod = parseInt(document.getElementById('scale-method').value) || 1;
                const seeds = getSeeds();

                // Determine target dimensions
                let processWidth = originalWidth;
                let processHeight = originalHeight;
                if (doDownscale) {
                    processWidth = parseInt(document.getElementById('scale-width').value) || originalWidth;
                    processHeight = parseInt(document.getElementById('scale-height').value) || originalHeight;
                }

                // Determine if linear processing is needed
                // Grayscale requires linear for correct luminance computation
                // Rescale requires linear for correct interpolation
                // Non-sRGB ICC profile requires linear (ICC transform outputs linear)
                const needsLinear = isGrayscale || doDownscale || inputHasNonSrgbIcc;

                const pixelCount = processWidth * processHeight;
                const outputData = new Uint8ClampedArray(pixelCount * 4);

                let currentWidth = originalWidth;
                let currentHeight = originalHeight;

                if (needsLinear) {
                    // Decode to f32 0-1 for linear processing
                    const decoded = decodeToNormalized(inputFileBytes);
                    let srgbNorm = decoded.pixels;
                    let linearRgb;

                    // Step 1: Convert to linear (either via ICC or sRGB gamma)
                    if (inputHasNonSrgbIcc) {
                        // ICC profile → linear sRGB
                        linearRgb = transform_icc_to_linear_srgb_wasm(
                            srgbNorm, currentWidth, currentHeight, getIccProfile(inputFileBytes)
                        );
                    } else {
                        // sRGB → linear
                        linearRgb = srgb_to_linear_f32_wasm(srgbNorm, currentWidth, currentHeight);
                    }

                    // Step 2: Rescale in linear space (if needed)
                    if (doDownscale) {
                        // Use uniform scaling based on primary dimension for exact AR preservation
                        const scaleMode = primaryDimension === 'width'
                            ? SCALE_MODE_UNIFORM_WIDTH
                            : SCALE_MODE_UNIFORM_HEIGHT;
                        linearRgb = rescale_linear_rgb_wasm(
                            linearRgb,
                            currentWidth, currentHeight,
                            processWidth, processHeight,
                            scaleMethod,
                            scaleMode
                        );
                        currentWidth = processWidth;
                        currentHeight = processHeight;
                    }

                    if (isGrayscale) {
                        // Step 3a: Convert to grayscale in linear space
                        const linearGray = linear_rgb_to_grayscale_wasm(linearRgb, currentWidth, currentHeight);

                        // Step 4a: Convert linear to sRGB (0-1 -> 0-1)
                        const srgbGrayNorm = linear_gray_to_srgb_f32_wasm(linearGray);

                        // Step 5a: Denormalize to 0-255
                        const srgbGray = denormalize_gray_f32_wasm(srgbGrayNorm);

                        // Step 6a: Dither grayscale
                        const bitsGray = parseInt(document.getElementById('bits-gray').value);
                        const isPerceptual = document.getElementById('perceptual-toggle').checked;

                        let grayDithered;
                        if (isPerceptual) {
                            const perceptualSpace = parseInt(document.getElementById('perceptual-space').value);
                            grayDithered = colorspace_aware_dither_gray_with_mode_wasm(
                                srgbGray,
                                currentWidth, currentHeight,
                                bitsGray,
                                perceptualSpace,
                                mode,
                                seeds.r
                            );
                        } else {
                            grayDithered = ditherChannel(srgbGray, currentWidth, currentHeight, mode, seeds.r, bitsGray);
                        }

                        // Output as grayscale (R=G=B)
                        for (let i = 0; i < pixelCount; i++) {
                            const v = grayDithered[i];
                            outputData[i * 4] = v;
                            outputData[i * 4 + 1] = v;
                            outputData[i * 4 + 2] = v;
                            outputData[i * 4 + 3] = 255;
                        }
                    } else {
                        // Step 3b: Convert back to sRGB (0-1)
                        const srgbResizedNorm = linear_to_srgb_f32_wasm(linearRgb, currentWidth, currentHeight);

                        // Step 4b: Denormalize to 0-255 for dithering
                        const srgbF32_255 = denormalize_f32_wasm(srgbResizedNorm, currentWidth, currentHeight);

                        // Step 5b: Dither RGB
                        const bitsR = parseInt(document.getElementById('bits-r').value);
                        const bitsG = parseInt(document.getElementById('bits-g').value);
                        const bitsB = parseInt(document.getElementById('bits-b').value);
                        const isPerceptual = document.getElementById('perceptual-toggle').checked;
                        const perceptualSpace = parseInt(document.getElementById('perceptual-space').value);
                        const technique = isPerceptual ? 2 : 1;

                        const rgbDithered = dither_output_wasm(
                            srgbF32_255,
                            currentWidth, currentHeight,
                            bitsR, bitsG, bitsB,
                            technique,
                            mode,
                            perceptualSpace,
                            seeds.r
                        );

                        for (let i = 0; i < pixelCount; i++) {
                            outputData[i * 4] = rgbDithered[i * 3];
                            outputData[i * 4 + 1] = rgbDithered[i * 3 + 1];
                            outputData[i * 4 + 2] = rgbDithered[i * 3 + 2];
                            outputData[i * 4 + 3] = 255;
                        }
                    }
                } else {
                    // sRGB-direct path: decode directly to f32 0-255, no intermediate
                    // 8-bit: u8 as f32 (no arithmetic)
                    // 16-bit: u16 * 255.0 / 65535.0 (single operation)
                    const decoded = decodeToSrgb255(inputFileBytes);
                    const srgbF32_255 = decoded.pixels;

                    const bitsR = parseInt(document.getElementById('bits-r').value);
                    const bitsG = parseInt(document.getElementById('bits-g').value);
                    const bitsB = parseInt(document.getElementById('bits-b').value);
                    const isPerceptual = document.getElementById('perceptual-toggle').checked;
                    const perceptualSpace = parseInt(document.getElementById('perceptual-space').value);
                    const technique = isPerceptual ? 2 : 1;

                    const rgbDithered = dither_output_wasm(
                        srgbF32_255,
                        currentWidth, currentHeight,
                        bitsR, bitsG, bitsB,
                        technique,
                        mode,
                        perceptualSpace,
                        seeds.r
                    );

                    for (let i = 0; i < pixelCount; i++) {
                        outputData[i * 4] = rgbDithered[i * 3];
                        outputData[i * 4 + 1] = rgbDithered[i * 3 + 1];
                        outputData[i * 4 + 2] = rgbDithered[i * 3 + 2];
                        outputData[i * 4 + 3] = 255;
                    }
                }

                // Create output image
                let outputImageData = new ImageData(outputData, processWidth, processHeight);

                // Upscale for viewing if enabled
                let displayWidth = processWidth;
                let displayHeight = processHeight;
                if (doUpscale && upscaleFactor > 1) {
                    outputImageData = upscaleNearestNeighbor(outputImageData, processWidth, processHeight, upscaleFactor);
                    displayWidth = processWidth * upscaleFactor;
                    displayHeight = processHeight * upscaleFactor;
                }

                const canvas = document.createElement('canvas');
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                const ctx = canvas.getContext('2d');
                ctx.putImageData(outputImageData, 0, 0);

                // Display results
                const outputUrl = canvas.toDataURL('image/png');
                document.getElementById('compare-input').src = document.getElementById('input-preview').src;
                document.getElementById('compare-output').src = outputUrl;
                document.getElementById('download-btn').href = outputUrl;

                // Store dither result for binary downloads
                lastDitherResult = {
                    width: processWidth,
                    height: processHeight,
                    isGrayscale,
                    bitsR: isGrayscale ? parseInt(document.getElementById('bits-gray').value) : parseInt(document.getElementById('bits-r').value),
                    bitsG: isGrayscale ? 0 : parseInt(document.getElementById('bits-g').value),
                    bitsB: isGrayscale ? 0 : parseInt(document.getElementById('bits-b').value),
                    mode: mode,
                    perceptualSpace: document.getElementById('perceptual-toggle').checked ?
                        parseInt(document.getElementById('perceptual-space').value) : null,
                    seed: parseInt(document.getElementById('seed-input').value) || 0,
                    // Store channel data
                    rChannel: null,
                    gChannel: null,
                    bChannel: null,
                    grayChannel: null
                };

                if (isGrayscale) {
                    // Extract gray channel from output
                    const grayData = new Uint8Array(pixelCount);
                    for (let i = 0; i < pixelCount; i++) {
                        grayData[i] = outputData[i * 4];
                    }
                    lastDitherResult.grayChannel = grayData;
                } else {
                    // Extract RGB channels from output
                    const rData = new Uint8Array(pixelCount);
                    const gData = new Uint8Array(pixelCount);
                    const bData = new Uint8Array(pixelCount);
                    for (let i = 0; i < pixelCount; i++) {
                        rData[i] = outputData[i * 4];
                        gData[i] = outputData[i * 4 + 1];
                        bData[i] = outputData[i * 4 + 2];
                    }
                    lastDitherResult.rChannel = rData;
                    lastDitherResult.gChannel = gData;
                    lastDitherResult.bChannel = bData;
                }

                // Update download buttons
                updateDownloadButtons();

                // Generate and display CLI command
                const cliCommand = generateCliCommand();
                document.getElementById('cli-command').textContent = cliCommand;

                outputSection.style.display = 'block';
            } catch (err) {
                console.error('Processing error:', err);
                errorMsg.textContent = `Error: ${err.message}`;
                errorMsg.classList.add('visible');
            } finally {
                loading.classList.remove('active');
            }
        }

        // Get format string from current settings
        function getFormatString() {
            const isGrayscale = document.getElementById('grayscale-toggle').checked;
            if (isGrayscale) {
                const bits = parseInt(document.getElementById('bits-gray').value);
                return `L${bits}`;
            } else {
                const bitsR = parseInt(document.getElementById('bits-r').value);
                const bitsG = parseInt(document.getElementById('bits-g').value);
                const bitsB = parseInt(document.getElementById('bits-b').value);
                return `RGB${bitsR}${bitsG}${bitsB}`;
            }
        }

        // Update download button states based on format
        function updateDownloadButtons() {
            if (!lastDitherResult) return;

            const format = getFormatString();
            const totalBits = format_total_bits_wasm(format);
            const supportsBinary = format_supports_binary_wasm(format);

            // Update format info
            const formatInfo = document.getElementById('format-info');
            if (supportsBinary) {
                formatInfo.textContent = `Format: ${format} (${totalBits} bits/pixel) - raw download available`;
            } else {
                formatInfo.textContent = `Format: ${format} (${totalBits} bits/pixel) - raw not supported (needs 1/2/4/8/16/24/32 bpp)`;
            }

            // Enable/disable raw download buttons
            document.getElementById('download-raw-btn').disabled = !supportsBinary;
            document.getElementById('download-raw-r-btn').disabled = !supportsBinary;

            // Per-channel downloads
            const channelDownloads = document.getElementById('channel-downloads');
            if (lastDitherResult.isGrayscale) {
                channelDownloads.style.display = 'none';
            } else {
                channelDownloads.style.display = 'block';
                // Enable channel buttons based on individual bit depths
                const rBits = lastDitherResult.bitsR;
                const gBits = lastDitherResult.bitsG;
                const bBits = lastDitherResult.bitsB;
                document.getElementById('download-r-btn').disabled = ![1,2,4,8].includes(rBits);
                document.getElementById('download-g-btn').disabled = ![1,2,4,8].includes(gBits);
                document.getElementById('download-b-btn').disabled = ![1,2,4,8].includes(bBits);
            }
        }

        // Download helper function
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Generate CLI command based on current settings
        function generateCliCommand() {
            const isGrayscale = document.getElementById('grayscale-toggle').checked;
            const isPerceptual = document.getElementById('perceptual-toggle').checked;
            const mode = parseInt(document.getElementById('dither-mode').value);
            const seed = parseInt(document.getElementById('seed-input').value) || 0;
            const doDownscale = document.getElementById('downscale-toggle').checked;

            // Map dither mode values to CLI names
            const modeMap = {
                0: 'fs-standard',
                1: 'fs-serpentine',
                2: 'jjn-standard',
                3: 'jjn-serpentine',
                4: 'mixed-standard',
                5: 'mixed-serpentine',
                6: 'mixed-random'
            };

            // Map perceptual space values to CLI names
            const spaceMap = {
                0: 'lab-cie76',
                1: 'oklab',
                2: 'lab-cie94',
                3: 'lab-ciede2000',
                4: 'linear-rgb',
                5: 'y-cb-cr'
            };

            // Use cra tool for dither (--histogram defaults to none when no --ref)
            let cmd = 'cra -i input.png -o output.png';

            // Add format (only if not default RGB888)
            if (isGrayscale) {
                const bitsGray = parseInt(document.getElementById('bits-gray').value);
                cmd += ` --format L${bitsGray}`;
            } else {
                const bitsR = parseInt(document.getElementById('bits-r').value);
                const bitsG = parseInt(document.getElementById('bits-g').value);
                const bitsB = parseInt(document.getElementById('bits-b').value);
                if (bitsR !== 8 || bitsG !== 8 || bitsB !== 8) {
                    cmd += ` --format RGB${bitsR}${bitsG}${bitsB}`;
                }
            }

            // Add dither mode (only if not default mixed-standard)
            if (mode !== 4) {
                cmd += ` --output-dither ${modeMap[mode]}`;
            }

            // Add colorspace-aware output options
            if (isPerceptual) {
                const perceptualSpace = parseInt(document.getElementById('perceptual-space').value);
                // Default is oklab for RGB, lab-cie94 for grayscale
                const defaultSpace = isGrayscale ? 2 : 1; // 2 = lab-cie94, 1 = oklab
                if (perceptualSpace !== defaultSpace) {
                    cmd += ` --output-distance-space ${spaceMap[perceptualSpace]}`;
                }
            } else {
                // Colorspace-aware is ON by default, add flag to disable
                cmd += ' --no-colorspace-aware-output';
            }

            // Add seed for mixed modes (only if not default 12345)
            if (mode >= 4 && mode <= 6 && seed !== 12345) {
                cmd += ` --seed ${seed}`;
            }

            // Add resize if downscaling (only primary dimension, other is derived from aspect ratio)
            if (doDownscale) {
                const scaleMethod = parseInt(document.getElementById('scale-method').value) || 1;
                const scaleMethodMap = { 0: 'bilinear', 1: 'lanczos' };
                if (primaryDimension === 'height') {
                    const height = parseInt(document.getElementById('scale-height').value);
                    cmd += ` --height ${height}`;
                } else {
                    const width = parseInt(document.getElementById('scale-width').value);
                    cmd += ` --width ${width}`;
                }
                // Only add scale method if not default lanczos
                if (scaleMethod !== 1) {
                    cmd += ` --scale-method ${scaleMethodMap[scaleMethod]}`;
                }
            }

            return cmd;
        }

        // Generate metadata JSON
        function generateMetadata() {
            if (!lastDitherResult) return null;

            const format = getFormatString();
            const stride = parseInt(document.getElementById('stride-select').value) || 1;
            const fill = parseInt(document.getElementById('stride-fill-select').value) || 0;
            const fillNames = ['Black', 'Repeat'];
            const modeNames = ['fs-standard', 'fs-serpentine', 'jjn-standard', 'jjn-serpentine',
                               'mixed-standard', 'mixed-serpentine', 'mixed-random'];
            const spaceNames = ['lab-cie76', 'oklab', 'lab-cie94', 'lab-ciede2000', 'linear-rgb', 'ycbcr'];

            return {
                format: format,
                width: lastDitherResult.width,
                height: lastDitherResult.height,
                is_grayscale: lastDitherResult.isGrayscale,
                bits_per_pixel: format_total_bits_wasm(format),
                bits_r: lastDitherResult.bitsR,
                bits_g: lastDitherResult.bitsG,
                bits_b: lastDitherResult.bitsB,
                dither_method: modeNames[lastDitherResult.mode] || 'unknown',
                colorspace: lastDitherResult.perceptualSpace !== null ?
                    spaceNames[lastDitherResult.perceptualSpace] || 'unknown' : 'none',
                seed: lastDitherResult.seed,
                stride: stride,
                stride_fill: fillNames[fill] || 'Black',
                generated_at: new Date().toISOString()
            };
        }

        // Event handlers
        document.getElementById('input-file').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                // Load file bytes (decoded on demand in processImage based on mode)
                const fileBytes = await loadImageBytes(file);

                // Quick decode just to get dimensions and ICC info
                const decoded = decodeToSrgb255(fileBytes);

                // Check for non-sRGB ICC profile (auto detection)
                inputHasNonSrgbIcc = checkNonSrgbIcc(fileBytes, decoded.hasIcc);
                if (inputHasNonSrgbIcc) {
                    console.log('Detected non-sRGB ICC profile - will use color management');
                }

                // Store raw bytes for processing
                inputFileBytes = fileBytes;
                inputWidth = decoded.width;
                inputHeight = decoded.height;
                originalWidth = decoded.width;
                originalHeight = decoded.height;
                aspectRatio = decoded.width / decoded.height;

                // Create preview image for display (using DataURL for compatibility)
                const previewUrl = await createPreview(file);
                const preview = document.getElementById('input-preview');
                preview.src = previewUrl;
                preview.style.display = 'block';

                const uploadBox = document.getElementById('input-upload');
                uploadBox.classList.add('has-image');
                uploadBox.querySelectorAll('.hint, label').forEach(el => el.style.display = 'none');

                // Set initial scale values (default to 128 on longest edge)
                const maxDim = 128;
                if (aspectRatio >= 1) {
                    document.getElementById('scale-width').value = maxDim;
                    document.getElementById('scale-height').value = Math.round(maxDim / aspectRatio);
                } else {
                    document.getElementById('scale-height').value = maxDim;
                    document.getElementById('scale-width').value = Math.round(maxDim * aspectRatio);
                }

                updateProcessButton();

                if (decoded.is16bit) {
                    console.log('Loaded 16-bit image');
                }
            } catch (err) {
                console.error('Failed to load image:', err);
            }
        });

        document.getElementById('process-btn').addEventListener('click', processImage);

        // Slider label updates
        function updateBitLabel(channel) {
            const slider = document.getElementById(`bits-${channel}`);
            const label = document.getElementById(`bits-${channel}-label`);
            const bits = parseInt(slider.value);
            const levels = 1 << bits;
            label.textContent = `${bits} bit${bits > 1 ? 's' : ''} (${levels} levels)`;
        }

        ['r', 'g', 'b', 'gray'].forEach(channel => {
            document.getElementById(`bits-${channel}`).addEventListener('input', () => updateBitLabel(channel));
        });

        // Grayscale toggle
        function updateGrayscaleMode() {
            const isGrayscale = document.getElementById('grayscale-toggle').checked;
            document.getElementById('rgb-options').classList.toggle('hidden', isGrayscale);
            document.getElementById('grayscale-options').classList.toggle('active', isGrayscale);
            // Grayscale now works with color space aware mode, no need to disable it
        }

        document.getElementById('grayscale-toggle').addEventListener('change', updateGrayscaleMode);

        // Color space aware toggle
        function updatePerceptualMode() {
            const isPerceptual = document.getElementById('perceptual-toggle').checked;
            document.getElementById('perceptual-options').classList.toggle('visible', isPerceptual);
            // Dither mode is now available for both basic and color-space aware modes
            updateSeedVisibility();
            // Color space aware now works with grayscale mode, no need to disable it
        }

        document.getElementById('perceptual-toggle').addEventListener('change', updatePerceptualMode);

        // Downscale toggle
        function updateDownscaleVisibility() {
            const doDownscale = document.getElementById('downscale-toggle').checked;
            document.getElementById('scale-options').classList.toggle('visible', doDownscale);
        }

        document.getElementById('downscale-toggle').addEventListener('change', updateDownscaleVisibility);

        // Upscale toggle
        function updateUpscaleVisibility() {
            const doUpscale = document.getElementById('upscale-toggle').checked;
            document.getElementById('upscale-options').classList.toggle('visible', doUpscale);
        }

        document.getElementById('upscale-toggle').addEventListener('change', updateUpscaleVisibility);

        // Size input handlers (maintain aspect ratio)
        document.getElementById('scale-width').addEventListener('input', updateSizeFromWidth);
        document.getElementById('scale-height').addEventListener('input', updateSizeFromHeight);

        // Show/hide seed options based on dither mode (only for mixed modes 4, 5, 6)
        // Now works for both basic and color-space aware modes
        function updateSeedVisibility() {
            const mode = parseInt(document.getElementById('dither-mode').value);
            const isMixedMode = mode >= 4 && mode <= 6;
            document.getElementById('seed-options').classList.toggle('visible', isMixedMode);
        }

        document.getElementById('dither-mode').addEventListener('change', updateSeedVisibility);

        // Drag and drop support
        const uploadBox = document.getElementById('input-upload');

        uploadBox.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadBox.style.borderColor = '#3498db';
            uploadBox.style.background = '#f8f9fa';
        });

        uploadBox.addEventListener('dragleave', (e) => {
            e.preventDefault();
            if (!uploadBox.classList.contains('has-image')) {
                uploadBox.style.borderColor = '#ccc';
                uploadBox.style.background = '';
            }
        });

        uploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadBox.style.borderColor = uploadBox.classList.contains('has-image') ? '#27ae60' : '#ccc';
            uploadBox.style.background = '';

            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                const input = document.getElementById('input-file');
                const dt = new DataTransfer();
                dt.items.add(file);
                input.files = dt.files;
                input.dispatchEvent(new Event('change'));
            }
        });

        // Raw download handlers
        document.getElementById('download-raw-btn').addEventListener('click', () => {
            if (!lastDitherResult) return;

            const format = getFormatString();
            const fill = parseInt(document.getElementById('stride-fill-select').value) || 0;
            let rawData;

            if (lastDitherResult.isGrayscale) {
                rawData = encode_gray_packed_wasm(
                    lastDitherResult.grayChannel,
                    lastDitherResult.width,
                    lastDitherResult.height,
                    lastDitherResult.bitsR
                );
            } else {
                rawData = encode_rgb_packed_wasm(
                    lastDitherResult.rChannel,
                    lastDitherResult.gChannel,
                    lastDitherResult.bChannel,
                    lastDitherResult.width,
                    lastDitherResult.height,
                    lastDitherResult.bitsR,
                    lastDitherResult.bitsG,
                    lastDitherResult.bitsB,
                    fill
                );
            }

            const blob = new Blob([rawData], { type: 'application/octet-stream' });
            downloadBlob(blob, `dithered_${format}.raw`);
        });

        document.getElementById('download-raw-r-btn').addEventListener('click', () => {
            if (!lastDitherResult) return;

            const format = getFormatString();
            const stride = parseInt(document.getElementById('stride-select').value) || 1;
            const fill = parseInt(document.getElementById('stride-fill-select').value) || 0;
            let rawData;

            if (lastDitherResult.isGrayscale) {
                rawData = encode_gray_row_aligned_stride_wasm(
                    lastDitherResult.grayChannel,
                    lastDitherResult.width,
                    lastDitherResult.height,
                    lastDitherResult.bitsR,
                    stride,
                    fill
                );
            } else {
                rawData = encode_rgb_row_aligned_stride_wasm(
                    lastDitherResult.rChannel,
                    lastDitherResult.gChannel,
                    lastDitherResult.bChannel,
                    lastDitherResult.width,
                    lastDitherResult.height,
                    lastDitherResult.bitsR,
                    lastDitherResult.bitsG,
                    lastDitherResult.bitsB,
                    stride,
                    fill
                );
            }

            const blob = new Blob([rawData], { type: 'application/octet-stream' });
            const strideSuffix = stride > 1 ? `_stride${stride}` : '';
            downloadBlob(blob, `dithered_${format}_row${strideSuffix}.raw`);
        });

        document.getElementById('download-meta-btn').addEventListener('click', () => {
            const metadata = generateMetadata();
            if (!metadata) return;

            const json = JSON.stringify(metadata, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            downloadBlob(blob, 'dither_metadata.json');
        });

        // Per-channel download handler helper
        function downloadChannel(channelName, channelData, bits) {
            if (!lastDitherResult || !channelData) return;

            const rawData = encode_channel_packed_wasm(
                channelData,
                lastDitherResult.width,
                lastDitherResult.height,
                bits
            );

            const blob = new Blob([rawData], { type: 'application/octet-stream' });
            downloadBlob(blob, `dithered_${channelName}${bits}.raw`);
        }

        document.getElementById('download-r-btn').addEventListener('click', () =>
            downloadChannel('R', lastDitherResult?.rChannel, lastDitherResult?.bitsR));
        document.getElementById('download-g-btn').addEventListener('click', () =>
            downloadChannel('G', lastDitherResult?.gChannel, lastDitherResult?.bitsG));
        document.getElementById('download-b-btn').addEventListener('click', () =>
            downloadChannel('B', lastDitherResult?.bChannel, lastDitherResult?.bitsB));

        // Initialize
        initWasm();
    </script>
</body>
</html>
