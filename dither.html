<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dithering Demo</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
            color: #333;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }

        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .upload-box {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
        }

        .upload-box:hover {
            border-color: #3498db;
            background: #f8f9fa;
        }

        .upload-box.has-image {
            border-style: solid;
            border-color: #27ae60;
        }

        .upload-box img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 4px;
        }

        .upload-box label {
            font-weight: 600;
            color: #555;
            margin-bottom: 10px;
            display: block;
        }

        .upload-box .hint {
            color: #888;
            font-size: 14px;
        }

        input[type="file"] {
            display: none;
        }

        .options-section {
            margin-bottom: 30px;
        }

        .options-section h3 {
            margin-bottom: 15px;
            color: #555;
        }

        .option-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .option-row label {
            font-weight: 600;
            min-width: 120px;
            color: #555;
        }

        .option-row select {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        .channel-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .channel-options.has-alpha {
            grid-template-columns: repeat(4, 1fr);
        }

        @media (max-width: 768px) {
            .channel-options {
                grid-template-columns: 1fr;
            }
            .channel-options.has-alpha {
                grid-template-columns: 1fr;
            }
        }

        .channel-box {
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .channel-box.red { background: #ffebee; border: 2px solid #e57373; }
        .channel-box.green { background: #e8f5e9; border: 2px solid #81c784; }
        .channel-box.blue { background: #e3f2fd; border: 2px solid #64b5f6; }
        .channel-box.alpha { background: #f3e5f5; border: 2px solid #ba68c8; }
        .channel-box.alpha h4 { color: #7b1fa2; }
        .channel-box.alpha .alpha-hint { font-size: 11px; color: #888; margin-top: 5px; }

        .channel-box h4 {
            margin: 0 0 10px 0;
        }

        .channel-box.red h4 { color: #c62828; }
        .channel-box.green h4 { color: #2e7d32; }
        .channel-box.blue h4 { color: #1565c0; }

        .channel-box input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }

        .bit-value {
            font-size: 14px;
            color: #555;
            font-weight: 500;
        }

        .toggle-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .toggle-row > span {
            font-weight: 600;
            color: #555;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #555;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .channel-box.gray {
            background: #f5f5f5;
            border: 2px solid #888;
        }

        .channel-box.gray h4 {
            color: #555;
        }

        .grayscale-options {
            display: none;
        }

        .grayscale-options.active {
            display: block;
        }

        .rgb-options.hidden {
            display: none;
        }

        .seed-options {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .seed-options.visible {
            display: block;
        }

        .perceptual-options {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #f3e5f5;
            border-radius: 8px;
            border: 1px solid #ce93d8;
        }

        .perceptual-options.visible {
            display: block;
        }

        .perceptual-options label {
            font-weight: 600;
            color: #555;
            margin-right: 10px;
        }

        .perceptual-options select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .perceptual-options .perceptual-hint {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
        }

        .option-row.hidden {
            display: none;
        }

        .seed-options label {
            font-weight: 600;
            color: #555;
            margin-right: 10px;
        }

        .seed-options input[type="number"] {
            width: 120px;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .seed-options .seed-hint {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
        }

        .stride-options {
            margin-top: 15px;
            padding: 15px;
            background: #e8f4fd;
            border-radius: 8px;
            border: 1px solid #90caf9;
        }

        .stride-options label {
            font-weight: 600;
            color: #555;
            margin-right: 10px;
        }

        .stride-options select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .stride-options .stride-hint {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
        }

        .stride-options .stride-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .stride-options .stride-select-group,
        .stride-options .stride-fill-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .scale-options {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .scale-options.visible {
            display: block;
        }

        .scale-options .size-inputs {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .scale-options .size-inputs label {
            font-weight: 600;
            color: #555;
        }

        .scale-options .size-inputs input[type="number"] {
            width: 80px;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .scale-options .size-inputs input[type="number"].secondary-dimension {
            color: #999;
            background: #f5f5f5;
        }

        .scale-options .size-inputs span {
            color: #888;
        }

        .scale-options .scale-hint {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
        }

        .upscale-options {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #f0f8ff;
            border-radius: 8px;
            border: 1px solid #64b5f6;
        }

        .upscale-options.visible {
            display: block;
        }

        .upscale-options label {
            font-weight: 600;
            color: #555;
            margin-right: 10px;
        }

        .upscale-options input[type="number"] {
            width: 60px;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .upscale-options .upscale-hint {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
        }

        .process-btn {
            width: 100%;
            padding: 15px 30px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .process-btn:hover:not(:disabled) {
            background: #2980b9;
        }

        .process-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .output-section {
            text-align: center;
        }

        .output-section h3 {
            margin-bottom: 20px;
            color: #555;
        }

        .compare-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .compare-section {
                grid-template-columns: 1fr;
            }
        }

        .compare-box {
            text-align: center;
        }

        .compare-box img,
        .compare-box linear-img {
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .compare-box img {
            image-rendering: pixelated;
        }

        .compare-box p {
            margin-top: 10px;
            font-weight: 600;
            color: #555;
        }

        .download-btn {
            display: inline-block;
            margin-top: 15px;
            padding: 10px 25px;
            background: #27ae60;
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: background 0.3s ease;
            cursor: pointer;
            border: none;
            font-size: 14px;
        }

        .download-btn:hover {
            background: #219a52;
        }

        .download-section {
            margin-top: 25px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .download-section h4 {
            margin: 0 0 15px 0;
            color: #555;
        }

        .download-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .download-btn.secondary {
            background: #3498db;
        }

        .download-btn.secondary:hover {
            background: #2980b9;
        }

        .download-btn.tertiary {
            background: #9b59b6;
        }

        .download-btn.tertiary:hover {
            background: #8e44ad;
        }

        .download-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .format-info {
            font-size: 12px;
            color: #888;
            margin-top: 10px;
        }

        .channel-downloads {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e0e0e0;
        }

        .channel-downloads h5 {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 13px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            position: relative;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .sparkle-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 280px;
            height: 140px;
            margin-left: -140px;
            margin-top: -70px;
            pointer-events: none;
        }

        .sparkle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #fff 0%, #ffd700 40%, transparent 70%);
            border-radius: 50%;
            opacity: 0;
            animation: sparkle-float 2s ease-in-out infinite;
        }

        .sparkle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #ffd700, transparent);
            transform: translate(-50%, -50%);
        }

        .sparkle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 100%;
            background: linear-gradient(180deg, transparent, #ffd700, transparent);
            transform: translate(-50%, -50%);
        }

        .sparkle:nth-child(1) { left: 5%; top: 20%; animation-delay: 0s; }
        .sparkle:nth-child(2) { left: 15%; top: 70%; animation-delay: 0.3s; }
        .sparkle:nth-child(3) { left: 25%; top: 10%; animation-delay: 0.6s; }
        .sparkle:nth-child(4) { left: 35%; top: 80%; animation-delay: 0.9s; }
        .sparkle:nth-child(5) { left: 50%; top: 5%; animation-delay: 0.15s; }
        .sparkle:nth-child(6) { left: 65%; top: 85%; animation-delay: 0.45s; }
        .sparkle:nth-child(7) { left: 75%; top: 15%; animation-delay: 0.75s; }
        .sparkle:nth-child(8) { left: 85%; top: 65%; animation-delay: 0.2s; }
        .sparkle:nth-child(9) { left: 95%; top: 25%; animation-delay: 0.5s; }
        .sparkle:nth-child(10) { left: 10%; top: 45%; animation-delay: 0.8s; }
        .sparkle:nth-child(11) { left: 90%; top: 50%; animation-delay: 0.35s; }
        .sparkle:nth-child(12) { left: 45%; top: 90%; animation-delay: 0.65s; }

        @keyframes sparkle-float {
            0%, 100% {
                opacity: 0;
                transform: scale(0) rotate(0deg);
            }
            25% {
                opacity: 1;
                transform: scale(1) rotate(90deg);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.2) rotate(180deg);
            }
            75% {
                opacity: 0.5;
                transform: scale(0.8) rotate(270deg);
            }
        }

        .init-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .init-overlay.hidden {
            display: none;
        }

        .error-message {
            background: #fee;
            border: 1px solid #fcc;
            border-radius: 8px;
            padding: 15px;
            color: #c00;
            margin-top: 15px;
            display: none;
        }

        .error-message.visible {
            display: block;
        }

        /* Alpha checkerboard pattern for transparent images */
        .alpha-checkerboard {
            background-image:
                linear-gradient(45deg, #ccc 25%, transparent 25%),
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 16px 16px;
            background-position: 0 0, 0 8px, 8px -8px, -8px 0px;
            background-color: #fff;
        }

        .upload-box .alpha-checkerboard {
            display: inline-block;
            border-radius: 4px;
        }

        .compare-box .alpha-checkerboard {
            display: inline-block;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="init-overlay" id="init-overlay">
        <div class="spinner"></div>
        <h2>Loading Dither Demo...</h2>
        <p>Initializing WASM module...</p>
    </div>

    <h1>Dithering Demo</h1>
    <p class="subtitle">Error diffusion dithering with configurable bit depth per channel</p>

    <div class="container">
        <div class="upload-box" id="input-upload" onclick="document.getElementById('input-file').click()">
            <label>Input Image</label>
            <p class="hint">Click to upload or drag and drop</p>
            <input type="file" id="input-file" accept="image/*,.safetensors">
            <div id="input-preview-wrapper" class="alpha-checkerboard" style="display: none;">
                <img id="input-preview">
            </div>
        </div>

        <div class="options-section">
            <h3>Dither Settings</h3>

            <div class="toggle-row">
                <span>Color Space Aware:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="perceptual-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="perceptual-options visible" id="perceptual-options">
                <label for="perceptual-space">Distance Metric:</label>
                <select id="perceptual-space">
                    <option value="1">OKLab</option>
                    <option value="8" selected>* OKLab Lr (better for dark colors)</option>
                    <option value="9">OKLab Heavy Chroma (×4, for limited palettes)</option>
                    <option value="3">CIELAB (CIEDE2000)</option>
                    <option value="2">* CIELAB (CIE94)</option>
                    <option value="0">CIELAB (CIE76)</option>
                    <option value="4">Linear RGB (not recommended)</option>
                    <option value="5">Y'CbCr BT.709 (not recommended)</option>
                    <option value="6">sRGB (not recommended)</option>
                    <option value="7">Y'CbCr BT.601 legacy (not recommended)</option>
                </select>
                <p class="perceptual-hint">Uses perceptual distance for candidate selection with linear error diffusion. For RGB, processes channels jointly. For grayscale: CIE76=CIE94 (simple ΔL²), CIEDE2000 uses lightness-dependent weighting, OKLab uses different L curve.</p>

                <div class="toggle-row" style="margin-top: 8px;">
                    <span>Overshoot Penalty:</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="overshoot-penalty-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <p class="perceptual-hint">Penalizes quantization choices that would cause the opposing point to fall outside the color gamut. Reduces color fringing artifacts.</p>
            </div>

            <div class="option-row" id="dither-mode-row">
                <label for="dither-mode">Dither Mode:</label>
                <select id="dither-mode">
                    <option value="0">* Floyd-Steinberg (Standard)</option>
                    <option value="1">Floyd-Steinberg (Serpentine)</option>
                    <option value="2">* Jarvis-Judice-Ninke (Standard)</option>
                    <option value="3">Jarvis-Judice-Ninke (Serpentine)</option>
                    <option value="4" selected>* Mixed (Standard)</option>
                    <option value="5">Mixed (Serpentine)</option>
                    <option value="6">Mixed (Random Direction)</option>
                    <option value="7">None (Nearest Only)</option>
                </select>
            </div>

            <div class="option-row hidden" id="alpha-dither-mode-row">
                <label for="alpha-dither-mode">Alpha Dither Mode:</label>
                <select id="alpha-dither-mode">
                    <option value="255" selected>Same as Dither Mode</option>
                    <option value="0">* Floyd-Steinberg (Standard)</option>
                    <option value="1">Floyd-Steinberg (Serpentine)</option>
                    <option value="2">* Jarvis-Judice-Ninke (Standard)</option>
                    <option value="3">Jarvis-Judice-Ninke (Serpentine)</option>
                    <option value="4">* Mixed (Standard)</option>
                    <option value="5">Mixed (Serpentine)</option>
                    <option value="6">Mixed (Random Direction)</option>
                    <option value="7">None (Nearest Only)</option>
                </select>
                <p class="alpha-dither-hint">Separate dither mode for alpha channel. Only applies when output has alpha (ARGB, LA).</p>
            </div>

            <div class="seed-options visible" id="seed-options">
                <label for="seed-input">Seed:</label>
                <input type="number" id="seed-input" value="12345" min="0" max="4294967295">
                <p class="seed-hint">Controls random kernel selection in Mixed modes. Each channel uses a different derived seed.</p>
            </div>

            <div class="stride-options">
                <div class="stride-row">
                    <div class="stride-select-group">
                        <label for="stride-select">Binary Row Stride:</label>
                        <select id="stride-select">
                            <option value="1" selected>1 byte (no padding)</option>
                            <option value="2">2 bytes</option>
                            <option value="4">4 bytes</option>
                            <option value="8">8 bytes</option>
                            <option value="16">16 bytes</option>
                            <option value="32">32 bytes</option>
                            <option value="64">64 bytes</option>
                            <option value="128">128 bytes</option>
                        </select>
                    </div>
                    <div class="stride-fill-group">
                        <label for="stride-fill-select">Padding Fill:</label>
                        <select id="stride-fill-select">
                            <option value="0" selected>Black (zeros)</option>
                            <option value="1">Repeat last pixel</option>
                        </select>
                    </div>
                </div>
                <p class="stride-hint">Row stride aligns each row to the specified byte boundary. Stride 1 means packed (no padding). Padding fill also affects RGB666 partial groups (4-pixel boundaries).</p>
            </div>

            <div class="option-row">
                <label for="output-mode">Output Mode:</label>
                <select id="output-mode">
                    <option value="rgb" selected>RGB Bit Depth</option>
                    <option value="grayscale">Grayscale Bit Depth</option>
                    <option value="palette-websafe">Paletted Web-Safe (216 colors)</option>
                    <option value="palette-cga-5153">Paletted CGA 5153 (16 colors)</option>
                    <option value="palette-cga-bios">Paletted CGA BIOS (16 colors, try sRGB as distance metric)</option>
                    <option value="palette-cga-mode5">Paletted CGA Palette 1 (4 colors, try CIE76 as distance metric)</option>
                    <option value="palette-cga-palette1-5153">Paletted CGA Palette 1 5153 (4 colors, try CIE76 as distance metric)</option>
                </select>
            </div>

            <div class="toggle-row">
                <span>Downscale:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="downscale-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="scale-options" id="scale-options">
                <div class="size-inputs">
                    <label for="scale-width">Width:</label>
                    <input type="number" id="scale-width" value="128" min="1" max="4096">
                    <span>x</span>
                    <label for="scale-height">Height:</label>
                    <input type="number" id="scale-height" value="128" min="1" max="4096">
                </div>
                <div class="size-inputs" style="margin-top: 10px;">
                    <label for="scale-method">Method:</label>
                    <select id="scale-method">
                        <option value="13" selected>★ EWA Lanczos3 (jinc-based, recommended)</option>
                        <option value="12">EWA Lanczos2 (jinc-based, less ringing)</option>
                        <option value="21">EWA Lanczos3 Sharp (Robidoux, preserves lines)</option>
                        <option value="22">EWA Lanczos4 Sharpest (Robidoux, hash patterns)</option>
                        <option value="1">Lanczos3 (separable, faster)</option>
                        <option value="7">Lanczos2 (separable, less ringing)</option>
                        <option value="9">EWA Sinc-Lanczos3 (radial sinc, faster)</option>
                        <option value="8">EWA Sinc-Lanczos2 (radial sinc, faster)</option>
                        <option value="3">★ Catmull-Rom (sharp, low ringing)</option>
                        <option value="2">Mitchell (soft, minimal ringing)</option>
                        <option value="15">EWA Catmull-Rom (2D, sharp)</option>
                        <option value="14">EWA Mitchell (2D, soft)</option>
                        <option value="0">★ Bilinear (faster)</option>
                        <option value="20">★ Box (nearest up, area-average down)</option>
                        <option value="4">Sinc (research only, SLOW)</option>
                        <option value="16">Jinc (2D sinc analog, research only, SLOW)</option>
                        <option value="17">Stochastic Jinc (gather, probabilistic)</option>
                        <option value="18">Stochastic Jinc Scatter (scatter, probabilistic)</option>
                        <option value="19">Stochastic Jinc Scatter Normalized (scatter, normalized dest)</option>
                        <option value="5">Lanczos3 Scatter (experimental)</option>
                        <option value="6">Sinc Scatter (experimental, SLOW)</option>
                    </select>
                </div>
                <p class="scale-hint">Rescaling is performed in linear RGB space for correct color blending.</p>
            </div>

            <div id="hdr-options" style="display: none;">
                <div class="option-row">
                    <label for="tonemapping">Tonemapping:</label>
                    <select id="tonemapping">
                        <option value="none" selected>None</option>
                        <option value="aces">ACES (compress HDR→SDR)</option>
                        <option value="aces-inverse">ACES Inverse (expand SDR→HDR)</option>
                    </select>
                </div>

                <div class="option-row" id="supersample-row" style="display: none;">
                    <label for="supersample">Supersampling:</label>
                    <select id="supersample">
                        <option value="none" selected>None</option>
                        <option value="tent-volume">Tent Volume</option>
                    </select>
                </div>
            </div>

            <div class="toggle-row">
                <span>Upscale for viewing:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="upscale-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="upscale-options" id="upscale-options">
                <label for="upscale-factor">Scale factor:</label>
                <input type="number" id="upscale-factor" value="4" min="1" max="16">
                <span>x</span>
                <p class="upscale-hint">Integer upscaling with nearest neighbor for pixel-perfect viewing.</p>
            </div>

            <div class="channel-options rgb-options" id="rgb-options">
                <div class="channel-box red">
                    <h4>Red Channel</h4>
                    <input type="range" id="bits-r" min="1" max="8" value="3">
                    <p class="bit-value" id="bits-r-label">3 bits (8 levels)</p>
                </div>
                <div class="channel-box green">
                    <h4>Green Channel</h4>
                    <input type="range" id="bits-g" min="1" max="8" value="3">
                    <p class="bit-value" id="bits-g-label">3 bits (8 levels)</p>
                </div>
                <div class="channel-box blue">
                    <h4>Blue Channel</h4>
                    <input type="range" id="bits-b" min="1" max="8" value="2">
                    <p class="bit-value" id="bits-b-label">2 bits (4 levels)</p>
                </div>
                <div class="channel-box alpha" id="alpha-channel-box" style="display: none;">
                    <h4>Alpha Channel</h4>
                    <input type="range" id="bits-a" min="0" max="8" value="8">
                    <p class="bit-value" id="bits-a-label">8 bits (256 levels)</p>
                    <p class="alpha-hint">Set to 0 to strip alpha</p>
                </div>
            </div>

            <div class="grayscale-options" id="grayscale-options">
                <div class="channel-box gray">
                    <h4>Grayscale</h4>
                    <input type="range" id="bits-gray" min="1" max="8" value="4">
                    <p class="bit-value" id="bits-gray-label">4 bits (16 levels)</p>
                </div>
                <div class="channel-box alpha" id="grayscale-alpha-box" style="display: none;">
                    <h4>Alpha</h4>
                    <input type="range" id="bits-gray-alpha" min="0" max="8" value="4">
                    <p class="bit-value" id="bits-gray-alpha-label">4 bits (16 levels)</p>
                    <p class="alpha-hint">Set to 0 to strip alpha</p>
                </div>
            </div>
        </div>

        <button class="process-btn" id="process-btn" disabled>Apply Dithering</button>

        <div class="error-message" id="error-message"></div>

        <div class="loading" id="loading">
            <div class="sparkle-container">
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
                <div class="sparkle"></div>
            </div>
            <div class="spinner"></div>
            <p>Processing image...</p>
        </div>
    </div>

    <div class="container output-section" id="output-section" style="display: none;">
        <h3>Result</h3>
        <div class="compare-section">
            <div class="compare-box">
                <div class="alpha-checkerboard">
                    <img id="compare-input">
                </div>
                <p>Original</p>
            </div>
            <div class="compare-box">
                <div class="alpha-checkerboard">
                    <linear-img id="compare-output" method="lanczos"></linear-img>
                </div>
                <p>Dithered</p>
            </div>
        </div>

        <div class="download-section">
            <h4>Downloads</h4>
            <div class="download-row">
                <button class="download-btn" id="download-btn" disabled>PNG Image</button>
                <button class="download-btn secondary" id="download-raw-btn" disabled>Raw Binary</button>
                <button class="download-btn tertiary" id="download-meta-btn">Metadata JSON</button>
            </div>
            <p class="format-info" id="format-info">Format: RGB332 (8 bits/pixel) - raw download available</p>

            <div class="channel-downloads" id="channel-downloads">
                <h5>Per-Channel Raw</h5>
                <div class="download-row">
                    <button class="download-btn secondary" id="download-r-btn" disabled>R Channel</button>
                    <button class="download-btn secondary" id="download-g-btn" disabled>G Channel</button>
                    <button class="download-btn secondary" id="download-b-btn" disabled>B Channel</button>
                    <button class="download-btn secondary" id="download-a-btn" disabled style="display: none;">Alpha Channel</button>
                </div>
            </div>
        </div>

        <div class="cli-command-section" id="cli-command-section" style="margin-top: 20px;">
            <h4 style="margin-bottom: 10px; color: #555;">CLI command</h4>
            <pre class="cli-command" id="cli-command" style="background: #1e1e1e; color: #9cdcfe; padding: 15px; border-radius: 8px; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 13px; overflow-x: auto; white-space: pre-wrap; word-break: break-all;"></pre>
        </div>
    </div>

    <script type="module">
        import './linear-img.js';
        // Only import functions needed for main thread - processing is done in worker
        import init, {
            decode_metadata_with_icc_check_wasm,
            format_supports_binary_wasm,
            format_supports_palettized_wasm,
            format_total_bits_wasm,
            encode_rgb_row_aligned_stride_wasm,
            encode_argb_row_aligned_stride_wasm,
            encode_gray_row_aligned_stride_wasm,
            encode_la_row_aligned_stride_wasm,
            encode_channel_row_aligned_stride_wasm,
            encode_palettized_png_wasm,
            encode_png_rgb_wasm,
            encode_png_rgba_wasm,
            encode_png_gray_wasm,
            encode_png_gray_alpha_wasm
        } from './wasm_cra/cra_wasm.js';

        // Worker for background processing
        let worker = null;
        let workerReady = false;

        function initWorker() {
            worker = new Worker('./dither-worker.js', { type: 'module' });

            worker.onmessage = function(e) {
                const { type, ...data } = e.data;

                switch (type) {
                    case 'ready':
                        workerReady = true;
                        updateProcessButton();
                        break;

                    case 'progress':
                        // Update progress display (update the <p> inside loading div)
                        const loadingP = document.querySelector('#loading p');
                        if (loadingP && data.message) {
                            loadingP.textContent = `${data.message} (${data.percent}%)`;
                        }
                        break;

                    case 'complete':
                        handleDitherComplete(data.result);
                        break;

                    case 'error':
                        handleDitherError(data.message);
                        break;
                }
            };

            worker.onerror = function(e) {
                console.error('Worker error:', e);
                handleDitherError(e.message || 'Worker error');
            };

            worker.postMessage({ type: 'init' });
        }


        // Handle dither completion from worker
        function handleDitherComplete(result) {
            const loading = document.getElementById('loading');
            const outputSection = document.getElementById('output-section');

            // Create output ImageData from worker result
            let outputData = result.outputData;
            let processWidth = result.width;
            let processHeight = result.height;
            let outputImageData = new ImageData(new Uint8ClampedArray(outputData), processWidth, processHeight);

            // Upscale for viewing if enabled
            const doUpscale = document.getElementById('upscale-toggle').checked;
            const upscaleFactor = parseInt(document.getElementById('upscale-factor').value) || 1;
            let displayWidth = processWidth;
            let displayHeight = processHeight;
            if (doUpscale && upscaleFactor > 1) {
                outputImageData = upscaleNearestNeighbor(outputImageData, processWidth, processHeight, upscaleFactor);
                displayWidth = processWidth * upscaleFactor;
                displayHeight = processHeight * upscaleFactor;
            }

            const canvas = document.createElement('canvas');
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            const ctx = canvas.getContext('2d');
            ctx.putImageData(outputImageData, 0, 0);

            // Display results
            const outputUrl = canvas.toDataURL('image/png');
            document.getElementById('compare-input').src = document.getElementById('input-preview').src;
            document.getElementById('compare-output').src = outputUrl;

            // Enable the PNG download button (click handler will generate the actual PNG)
            const downloadBtn = document.getElementById('download-btn');
            downloadBtn.disabled = false;

            // Store dither result for binary downloads
            lastDitherResult = {
                width: processWidth,
                height: processHeight,
                isGrayscale: result.isGrayscale,
                bitsR: result.bitsR,
                bitsG: result.bitsG,
                bitsB: result.bitsB,
                bitsA: result.bitsA || 8,  // Alpha bit depth (default 8 if not specified)
                mode: result.mode,
                perceptualSpace: document.getElementById('perceptual-toggle').checked ?
                    parseInt(document.getElementById('perceptual-space').value) : null,
                seed: parseInt(document.getElementById('seed-input').value) || 0,
                rgbInterleaved: result.rgbInterleaved,
                rgbaInterleaved: result.rgbaInterleaved,
                grayChannel: result.grayChannel,
                laInterleaved: result.laInterleaved,
                hasAlpha: result.hasAlpha
            };

            // Update download buttons
            updateDownloadButtons();

            // Generate and display CLI command
            const cliCommand = generateCliCommand();
            document.getElementById('cli-command').textContent = cliCommand;

            loading.classList.remove('active');
            outputSection.style.display = 'block';
        }

        // Handle dither error from worker
        function handleDitherError(message) {
            const loading = document.getElementById('loading');
            const errorMsg = document.getElementById('error-message');

            console.error('Dither error:', message);
            errorMsg.textContent = `Error: ${message}`;
            errorMsg.classList.add('visible');
            loading.classList.remove('active');
        }

        let wasmReady = false;
        let inputFileBytes = null;      // Raw file bytes (decoded on demand based on processing mode)
        let inputHasNonSrgbIcc = false; // True if image has ICC profile that differs from sRGB
        let inputHasAlpha = false;      // True if input image has alpha channel
        let inputIsHdr = false;         // True if input is HDR (EXR/f32)
        let inputWidth = 0;
        let inputHeight = 0;
        let originalWidth = 0;
        let originalHeight = 0;
        let aspectRatio = 1;
        let updatingSize = false; // Prevent recursive updates
        let primaryDimension = 'width'; // 'width' or 'height' - which dimension is authoritative
        let processTimestamp = null; // Timestamp when processing started

        // Scale mode constants (must match Rust enum)
        const SCALE_MODE_INDEPENDENT = 0;
        const SCALE_MODE_UNIFORM_WIDTH = 1;
        const SCALE_MODE_UNIFORM_HEIGHT = 2;

        // Store last dithered result for binary downloads
        let lastDitherResult = null;

        // Generate download filename with timestamp
        function generateDownloadFilename(width, height, format, ext) {
            const ts = processTimestamp || Date.now();
            return `cra_${ts}_${width}x${height}_${format}.${ext}`;
        }

        // Initialize WASM and worker
        async function initWasm() {
            try {
                await init();
                wasmReady = true;
                // Start worker initialization (it will set workerReady when done)
                initWorker();
                document.getElementById('init-overlay').classList.add('hidden');
                updateProcessButton();
            } catch (err) {
                console.error('Failed to initialize WASM:', err);
                document.getElementById('init-overlay').innerHTML = `
                    <h2>Error Loading WASM</h2>
                    <p style="color: #c00;">${err.message}</p>
                `;
            }
        }

        // Update process button state
        function updateProcessButton() {
            const btn = document.getElementById('process-btn');
            btn.disabled = !wasmReady || !workerReady || !inputFileBytes;
        }

        // Load image file as ArrayBuffer (for precise WASM decoding)
        function loadImageBytes(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        // Create preview image from file (for display only)
        function createPreview(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Note: rescaleImageData removed - now using atomic pipeline in processImage

        // Upscale image data using nearest neighbor
        function upscaleNearestNeighbor(imageData, srcWidth, srcHeight, factor) {
            const dstWidth = srcWidth * factor;
            const dstHeight = srcHeight * factor;
            const srcData = imageData.data;
            const dstData = new Uint8ClampedArray(dstWidth * dstHeight * 4);

            for (let y = 0; y < dstHeight; y++) {
                const srcY = Math.floor(y / factor);
                for (let x = 0; x < dstWidth; x++) {
                    const srcX = Math.floor(x / factor);
                    const srcIdx = (srcY * srcWidth + srcX) * 4;
                    const dstIdx = (y * dstWidth + x) * 4;
                    dstData[dstIdx] = srcData[srcIdx];
                    dstData[dstIdx + 1] = srcData[srcIdx + 1];
                    dstData[dstIdx + 2] = srcData[srcIdx + 2];
                    dstData[dstIdx + 3] = srcData[srcIdx + 3];
                }
            }

            return new ImageData(dstData, dstWidth, dstHeight);
        }

        // Update size fields based on aspect ratio
        function updateSizeFromWidth() {
            if (updatingSize || !originalWidth) return;
            updatingSize = true;
            primaryDimension = 'width';
            const width = parseInt(document.getElementById('scale-width').value) || 1;
            const height = Math.round(width / aspectRatio);
            document.getElementById('scale-height').value = height;
            updatingSize = false;
            updateDimensionStyling();
        }

        function updateSizeFromHeight() {
            if (updatingSize || !originalHeight) return;
            updatingSize = true;
            primaryDimension = 'height';
            const height = parseInt(document.getElementById('scale-height').value) || 1;
            const width = Math.round(height * aspectRatio);
            document.getElementById('scale-width').value = width;
            updatingSize = false;
            updateDimensionStyling();
        }

        // Update visual styling to show which dimension is primary vs secondary
        function updateDimensionStyling() {
            const widthInput = document.getElementById('scale-width');
            const heightInput = document.getElementById('scale-height');
            if (primaryDimension === 'width') {
                widthInput.classList.remove('secondary-dimension');
                heightInput.classList.add('secondary-dimension');
            } else {
                heightInput.classList.remove('secondary-dimension');
                widthInput.classList.add('secondary-dimension');
            }
        }

        // Process the image using background worker
        async function processImage() {
            if (!inputFileBytes || !workerReady) return;

            // Store timestamp when processing starts
            processTimestamp = Date.now();

            const loading = document.getElementById('loading');
            const errorMsg = document.getElementById('error-message');
            const outputSection = document.getElementById('output-section');

            loading.classList.add('active');
            errorMsg.classList.remove('visible');
            outputSection.style.display = 'none';

            const mode = parseInt(document.getElementById('dither-mode').value);
            const outputMode = document.getElementById('output-mode').value;
            const isGrayscale = outputMode === 'grayscale';
            const isPaletted = outputMode.startsWith('palette-');
            // Palette type: 0=websafe, 1=cga-5153, 2=cga-bios, 3=cga-palette1, 4=cga-palette1-5153
            const paletteType = outputMode === 'palette-cga-5153' ? 1 : outputMode === 'palette-cga-bios' ? 2 : outputMode === 'palette-cga-mode5' ? 3 : outputMode === 'palette-cga-palette1-5153' ? 4 : 0;
            const doDownscale = document.getElementById('downscale-toggle').checked;
            const scaleMethod = parseInt(document.getElementById('scale-method').value) || 1;
            const isPerceptual = document.getElementById('perceptual-toggle').checked;
            const perceptualSpace = parseInt(document.getElementById('perceptual-space').value);
            const overshootPenalty = document.getElementById('overshoot-penalty-toggle').checked;
            const seed = parseInt(document.getElementById('seed-input').value) || 0;
            const tonemapping = document.getElementById('tonemapping').value;
            const supersample = document.getElementById('supersample').value;

            // Determine target dimensions
            let processWidth = originalWidth;
            let processHeight = originalHeight;
            if (doDownscale) {
                processWidth = parseInt(document.getElementById('scale-width').value) || originalWidth;
                processHeight = parseInt(document.getElementById('scale-height').value) || originalHeight;
            }

            // Get bit depths
            const bitsR = parseInt(document.getElementById('bits-r').value);
            const bitsG = parseInt(document.getElementById('bits-g').value);
            const bitsB = parseInt(document.getElementById('bits-b').value);
            const bitsA = parseInt(document.getElementById('bits-a').value);  // 0 = strip alpha
            const bitsGray = parseInt(document.getElementById('bits-gray').value);
            const bitsGrayA = parseInt(document.getElementById('bits-gray-alpha').value) || 0;  // 0 = strip alpha for grayscale

            // Get alpha mode (255 = same as mode)
            const alphaMode = parseInt(document.getElementById('alpha-dither-mode').value);

            // Send to worker
            worker.postMessage({
                type: 'dither',
                fileBytes: inputFileBytes,
                originalWidth: originalWidth,
                originalHeight: originalHeight,
                inputHasNonSrgbIcc: inputHasNonSrgbIcc,
                isGrayscale: isGrayscale,
                isPaletted: isPaletted,
                paletteType: paletteType,  // 0=websafe, 1=cga-5153, 2=cga-bios
                doDownscale: doDownscale,
                processWidth: processWidth,
                processHeight: processHeight,
                scaleMethod: scaleMethod,
                primaryDimension: primaryDimension,
                bitsR: bitsR,
                bitsG: bitsG,
                bitsB: bitsB,
                bitsA: bitsA,  // Alpha bit depth (0 = strip alpha)
                bitsGray: bitsGray,
                bitsGrayA: bitsGrayA,  // Grayscale alpha bit depth (0 = strip alpha for LA format)
                mode: mode,
                alphaMode: alphaMode,  // Separate alpha dither mode (255 = same as mode)
                isPerceptual: isPerceptual,
                perceptualSpace: perceptualSpace,
                overshootPenalty: overshootPenalty,
                seed: seed,
                tonemapping: tonemapping,
                supersample: supersample
            });
        }

        // Get format string from current settings
        function getFormatString() {
            const outputMode = document.getElementById('output-mode').value;

            if (outputMode === 'palette-websafe') {
                return 'PALETTE_WEBSAFE';
            } else if (outputMode === 'palette-cga-5153') {
                return 'PALETTE_CGA_5153';
            } else if (outputMode === 'palette-cga-bios') {
                return 'PALETTE_CGA_BIOS';
            } else if (outputMode === 'palette-cga-mode5') {
                return 'PALETTE_CGA_PALETTE1';
            } else if (outputMode === 'palette-cga-palette1-5153') {
                return 'PALETTE_CGA_PALETTE1_5153';
            } else if (outputMode === 'grayscale') {
                const bitsL = parseInt(document.getElementById('bits-gray').value);
                const bitsA = parseInt(document.getElementById('bits-gray-alpha').value);
                // Use LA format when input has alpha and alpha bits > 0
                if (inputHasAlpha && bitsA > 0) {
                    // Shorthand when bits are equal (LA4 instead of LA44)
                    return bitsL === bitsA ? `LA${bitsL}` : `LA${bitsL}${bitsA}`;
                }
                return `L${bitsL}`;
            } else {
                const bitsR = parseInt(document.getElementById('bits-r').value);
                const bitsG = parseInt(document.getElementById('bits-g').value);
                const bitsB = parseInt(document.getElementById('bits-b').value);
                const bitsA = parseInt(document.getElementById('bits-a').value);

                // Use ARGB format when alpha is preserved (bitsA > 0 and input has alpha)
                if (inputHasAlpha && bitsA > 0) {
                    // Shorthand when all bits are equal (ARGB8 instead of ARGB8888)
                    return (bitsA === bitsR && bitsR === bitsG && bitsG === bitsB)
                        ? `ARGB${bitsA}`
                        : `ARGB${bitsA}${bitsR}${bitsG}${bitsB}`;
                } else {
                    // Shorthand when all bits are equal (RGB8 instead of RGB888)
                    return (bitsR === bitsG && bitsG === bitsB)
                        ? `RGB${bitsR}`
                        : `RGB${bitsR}${bitsG}${bitsB}`;
                }
            }
        }

        // Update download button states based on format
        function updateDownloadButtons() {
            if (!lastDitherResult) return;

            const format = getFormatString();
            const totalBits = format_total_bits_wasm(format);
            const supportsBinary = format_supports_binary_wasm(format);

            // Update format info
            const formatInfo = document.getElementById('format-info');
            if (supportsBinary) {
                formatInfo.textContent = `Format: ${format} (${totalBits} bits/pixel) - raw download available`;
            } else {
                formatInfo.textContent = `Format: ${format} (${totalBits} bits/pixel) - raw not supported (needs 1/2/4/8/16/24/32 bpp)`;
            }

            // Enable/disable raw download buttons
            document.getElementById('download-raw-btn').disabled = !supportsBinary;

            // Per-channel downloads
            const channelDownloads = document.getElementById('channel-downloads');
            if (lastDitherResult.isGrayscale) {
                channelDownloads.style.display = 'none';
            } else {
                channelDownloads.style.display = 'block';
                // Enable channel buttons based on individual bit depths
                const rBits = lastDitherResult.bitsR;
                const gBits = lastDitherResult.bitsG;
                const bBits = lastDitherResult.bitsB;
                const aBits = lastDitherResult.bitsA || 8; // Default to 8 bits for alpha
                document.getElementById('download-r-btn').disabled = ![1,2,4,8].includes(rBits);
                document.getElementById('download-g-btn').disabled = ![1,2,4,8].includes(gBits);
                document.getElementById('download-b-btn').disabled = ![1,2,4,8].includes(bBits);

                // Show/enable alpha channel button if output has alpha
                const alphaBtn = document.getElementById('download-a-btn');
                if (lastDitherResult.hasAlpha) {
                    alphaBtn.style.display = 'inline-block';
                    alphaBtn.disabled = ![1,2,4,8].includes(aBits);
                } else {
                    alphaBtn.style.display = 'none';
                    alphaBtn.disabled = true;
                }
            }
        }

        // Download helper function
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Generate CLI command based on current settings
        function generateCliCommand() {
            const outputMode = document.getElementById('output-mode').value;
            const isGrayscale = outputMode === 'grayscale';
            const isPaletted = outputMode.startsWith('palette-');
            const isPerceptual = document.getElementById('perceptual-toggle').checked;
            const mode = parseInt(document.getElementById('dither-mode').value);
            const seed = parseInt(document.getElementById('seed-input').value) || 0;
            const doDownscale = document.getElementById('downscale-toggle').checked;

            // Map dither mode values to CLI names
            const modeMap = {
                0: 'fs-standard',
                1: 'fs-serpentine',
                2: 'jjn-standard',
                3: 'jjn-serpentine',
                4: 'mixed-standard',
                5: 'mixed-serpentine',
                6: 'mixed-random',
                7: 'none'
            };

            // Map perceptual space values to CLI names
            const spaceMap = {
                0: 'lab-cie76',
                1: 'oklab',
                2: 'lab-cie94',
                3: 'lab-ciede2000',
                4: 'linear-rgb',
                5: 'y-cb-cr',
                6: 'srgb',
                7: 'y-cb-cr-bt601',
                8: 'oklab-lr',
                9: 'oklab-heavy-chroma'
            };

            // Use cra tool for dither (--histogram defaults to none when no --ref)
            let cmd = 'cra -i input.png -o output.png';

            // Add format based on output mode
            if (isPaletted) {
                // Map output mode to CLI format name
                const paletteFormatMap = {
                    'palette-websafe': 'PALETTE_WEBSAFE',
                    'palette-cga-5153': 'PALETTE_CGA_5153',
                    'palette-cga-bios': 'PALETTE_CGA_BIOS',
                    'palette-cga-mode5': 'PALETTE_CGA_PALETTE1',
                    'palette-cga-palette1-5153': 'PALETTE_CGA_PALETTE1_5153'
                };
                cmd += ` --format ${paletteFormatMap[outputMode] || 'PALETTE_WEBSAFE'}`;
            } else if (isGrayscale) {
                const bitsGray = parseInt(document.getElementById('bits-gray').value);
                const bitsGrayA = parseInt(document.getElementById('bits-gray-alpha').value) || 0;
                // Use LA format when input has alpha and alpha bits > 0
                if (inputHasAlpha && bitsGrayA > 0) {
                    // Use shorthand (LA4) when bits are equal, otherwise full form (LA48)
                    const formatSuffix = (bitsGray === bitsGrayA) ? bitsGray : `${bitsGray}${bitsGrayA}`;
                    cmd += ` --format LA${formatSuffix}`;
                } else {
                    cmd += ` --format L${bitsGray}`;
                }
            } else {
                const bitsR = parseInt(document.getElementById('bits-r').value);
                const bitsG = parseInt(document.getElementById('bits-g').value);
                const bitsB = parseInt(document.getElementById('bits-b').value);
                const bitsA = parseInt(document.getElementById('bits-a').value);

                // Use ARGB format when alpha is preserved
                if (inputHasAlpha && bitsA > 0) {
                    // Default for alpha inputs is ARGB8888, only add if different
                    const isDefault = (bitsA === 8 && bitsR === 8 && bitsG === 8 && bitsB === 8);
                    if (!isDefault) {
                        // Use shorthand (ARGB8) when all channels are equal, otherwise full form (ARGB8888)
                        const allEqual = (bitsA === bitsR && bitsR === bitsG && bitsG === bitsB);
                        const formatSuffix = allEqual ? bitsA : `${bitsA}${bitsR}${bitsG}${bitsB}`;
                        cmd += ` --format ARGB${formatSuffix}`;
                    }
                } else if (bitsR !== 8 || bitsG !== 8 || bitsB !== 8) {
                    // Default for non-alpha inputs is RGB888, only add if different
                    // Use shorthand (RGB5) when all channels are equal, otherwise full form (RGB565)
                    const formatSuffix = (bitsR === bitsG && bitsG === bitsB) ? bitsR : `${bitsR}${bitsG}${bitsB}`;
                    cmd += ` --format RGB${formatSuffix}`;
                }
            }

            // Add dither mode (only if not default mixed-standard)
            if (mode !== 4) {
                cmd += ` --output-dither ${modeMap[mode]}`;
            }

            // Add alpha dither mode (only if not default "same as mode" = 255)
            // Not applicable for paletted mode (alpha is integrated)
            const alphaMode = parseInt(document.getElementById('alpha-dither-mode').value);
            const hasAlphaOutput = isPaletted
                ? false  // Paletted mode: alpha is integrated, no separate dither mode
                : isGrayscale
                    ? (inputHasAlpha && parseInt(document.getElementById('bits-gray-alpha').value) > 0)
                    : (inputHasAlpha && parseInt(document.getElementById('bits-a').value) > 0);
            if (hasAlphaOutput && alphaMode !== 255) {
                cmd += ` --output-alpha-dither ${modeMap[alphaMode]}`;
            }

            // Add colorspace-aware output options
            // Paletted modes always use colorspace-aware dithering
            if (isPerceptual || isPaletted) {
                const perceptualSpace = parseInt(document.getElementById('perceptual-space').value);
                // Default is oklab-lr for RGB, lab-cie94 for grayscale
                const defaultSpace = isGrayscale ? 2 : 8; // 2 = lab-cie94, 8 = oklab-lr
                if (perceptualSpace !== defaultSpace) {
                    cmd += ` --output-distance-space ${spaceMap[perceptualSpace]}`;
                }
                // Add overshoot penalty flag if disabled (enabled by default)
                const overshootPenalty = document.getElementById('overshoot-penalty-toggle').checked;
                if (!overshootPenalty) {
                    cmd += ' --no-overshoot-penalty';
                }
            } else {
                // Colorspace-aware is OFF, add flag to disable
                cmd += ' --no-colorspace-aware-output';
            }

            // Add seed for mixed modes (only if not default 12345)
            if (mode >= 4 && mode <= 6 && seed !== 12345) {
                cmd += ` --seed ${seed}`;
            }

            // Add resize if downscaling (only primary dimension, other is derived from aspect ratio)
            if (doDownscale) {
                const scaleMethod = parseInt(document.getElementById('scale-method').value) || 13;
                const scaleMethodMap = { 0: 'bilinear', 1: 'lanczos', 2: 'mitchell', 3: 'catmull-rom', 4: 'sinc', 5: 'lanczos-scatter', 6: 'sinc-scatter', 7: 'lanczos2', 8: 'ewa-sinc-lanczos2', 9: 'ewa-sinc-lanczos3', 12: 'ewa-lanczos2', 13: 'ewa-lanczos3', 14: 'ewa-mitchell', 15: 'ewa-catmull-rom', 16: 'jinc', 17: 'stochastic-jinc', 18: 'stochastic-jinc-scatter', 19: 'stochastic-jinc-scatter-normalized', 20: 'box', 21: 'ewa-lanczos3-sharp', 22: 'ewa-lanczos4-sharpest' };
                if (primaryDimension === 'height') {
                    const height = parseInt(document.getElementById('scale-height').value);
                    cmd += ` --height ${height}`;
                } else {
                    const width = parseInt(document.getElementById('scale-width').value);
                    cmd += ` --width ${width}`;
                }
                // Only add scale method if not default ewa-lanczos3
                if (scaleMethod !== 13) {
                    cmd += ` --scale-method ${scaleMethodMap[scaleMethod]}`;
                }
            }

            // Add tonemapping option
            const tonemapping = document.getElementById('tonemapping').value;
            if (tonemapping !== 'none') {
                cmd += ` --tonemapping ${tonemapping}`;
            }

            // Add supersampling option
            const supersample = document.getElementById('supersample').value;
            if (supersample !== 'none') {
                cmd += ` --supersample ${supersample}`;
            }

            return cmd;
        }

        // Generate metadata JSON
        function generateMetadata() {
            if (!lastDitherResult) return null;

            const format = getFormatString();
            const stride = parseInt(document.getElementById('stride-select').value) || 1;
            const fill = parseInt(document.getElementById('stride-fill-select').value) || 0;
            const fillNames = ['Black', 'Repeat'];
            const modeNames = ['FsStandard', 'FsSerpentine', 'JjnStandard', 'JjnSerpentine',
                               'MixedStandard', 'MixedSerpentine', 'MixedRandom', 'None'];
            const spaceNames = ['LabCie76', 'Oklab', 'LabCie94', 'LabCiede2000', 'LinearRgb', 'YCbCr', 'Srgb', 'YCbCrBt601', 'OklabLr', 'OklabHeavyChroma'];

            // Name matches output filename (without extension)
            const ts = processTimestamp || Date.now();
            const name = `cra_${ts}_${lastDitherResult.width}x${lastDitherResult.height}_${format}`;

            // Calculate raw output size (matches CLI calculation)
            const bitsPerPixel = format_total_bits_wasm(format);
            const packedRowBits = lastDitherResult.width * bitsPerPixel;
            const packedRowBytes = Math.ceil(packedRowBits / 8);
            const rowStride = stride > 1 ? Math.ceil(packedRowBytes / stride) * stride : packedRowBytes;
            const totalSize = rowStride * lastDitherResult.height;

            // Build metadata object matching CLI format
            // Order matches CLI: name, type, width, height, format fields, dither fields, raw fields, seed
            const metadata = {
                name: name,
                type: 'bitmap',
                width: lastDitherResult.width,
                height: lastDitherResult.height,
                format: format,
                bits_per_pixel: bitsPerPixel
            };

            // Bit depth fields (grayscale uses bits_l, RGB uses bits_r/g/b)
            if (lastDitherResult.isGrayscale) {
                metadata.bits_l = lastDitherResult.bitsR;
            } else {
                metadata.bits_r = lastDitherResult.bitsR;
                metadata.bits_g = lastDitherResult.bitsG;
                metadata.bits_b = lastDitherResult.bitsB;
            }
            if (lastDitherResult.hasAlpha) {
                metadata.bits_a = lastDitherResult.bitsA;
            }

            // Dither settings
            metadata.output_dither = modeNames[lastDitherResult.mode] || 'Unknown';
            if (lastDitherResult.hasAlpha && lastDitherResult.alphaMode !== undefined) {
                metadata.output_alpha_dither = modeNames[lastDitherResult.alphaMode] || 'Unknown';
            }
            // Perceptual space for dithering distance metric (defaults to OklabLr for RGB, LabCie94 for grayscale)
            const defaultSpace = lastDitherResult.isGrayscale ? 'LabCie94' : 'OklabLr';
            metadata.output_distance_space = lastDitherResult.perceptualSpace !== null ?
                (spaceNames[lastDitherResult.perceptualSpace] || defaultSpace) : defaultSpace;

            // Raw output fields
            metadata.stride_alignment = stride;
            metadata.stride_fill = fillNames[fill] || 'Black';
            metadata.compressed = 0;
            metadata.stride = rowStride;
            metadata.total_size = totalSize;

            // Seed
            metadata.seed = lastDitherResult.seed;

            return metadata;
        }

        // Core file handling logic - called from both file input and drag-drop
        async function handleFile(file) {
            if (!file) return;

            try {
                // Load file bytes (decoded on demand in worker based on mode)
                const fileBytes = await loadImageBytes(file);

                // Get metadata and ICC check in single parse (no pixel decode)
                const metadata = decode_metadata_with_icc_check_wasm(new Uint8Array(fileBytes));
                const width = metadata[0];
                const height = metadata[1];
                const hasNonSrgbIcc = metadata[2] > 0.5;
                const is16bit = metadata[3] > 0.5;
                const isF32 = metadata[4] > 0.5;
                const hasAlpha = metadata[5] > 0.5;

                // Store ICC, alpha, and HDR info for worker
                inputHasNonSrgbIcc = hasNonSrgbIcc;
                inputHasAlpha = hasAlpha;
                inputIsHdr = isF32;
                if (inputHasNonSrgbIcc) {
                    console.log('Detected non-sRGB ICC profile - will use color management');
                }
                if (inputHasAlpha) {
                    console.log('Detected alpha channel in input image');
                }
                if (inputIsHdr) {
                    console.log('Detected HDR (f32) image - showing tonemapping options');
                }

                // Show/hide alpha channel controls based on input
                updateAlphaControlVisibility();

                // Show/hide HDR options based on input format
                updateHdrOptionsVisibility();

                // Store raw bytes for processing
                inputFileBytes = fileBytes;
                inputWidth = width;
                inputHeight = height;
                originalWidth = width;
                originalHeight = height;
                aspectRatio = width / height;

                // Create preview image for display
                const uploadBox = document.getElementById('input-upload');
                const previewWrapper = document.getElementById('input-preview-wrapper');

                if (inputIsHdr) {
                    // EXR files can't be previewed in browser - show placeholder
                    previewWrapper.innerHTML = `
                        <div style="padding: 40px; background: linear-gradient(135deg, #2c3e50, #34495e); border-radius: 8px; color: #ecf0f1;">
                            <div style="font-size: 48px; margin-bottom: 10px;">HDR</div>
                            <div style="font-size: 14px; opacity: 0.8;">EXR format (${width}x${height})</div>
                        </div>
                    `;
                    previewWrapper.style.display = 'inline-block';
                } else {
                    // Standard image - use DataURL preview
                    const previewUrl = await createPreview(file);
                    previewWrapper.innerHTML = `<img id="input-preview" src="${previewUrl}" alt="Preview" style="max-width: 100%; max-height: 300px; border-radius: 4px;">`;
                    previewWrapper.style.display = 'inline-block';
                }

                uploadBox.classList.add('has-image');
                uploadBox.querySelectorAll('.hint, label').forEach(el => el.style.display = 'none');

                // Set initial scale values (default to 128 on longest edge)
                const maxDim = 128;
                if (aspectRatio >= 1) {
                    primaryDimension = 'width';
                    document.getElementById('scale-width').value = maxDim;
                    document.getElementById('scale-height').value = Math.round(maxDim / aspectRatio);
                } else {
                    primaryDimension = 'height';
                    document.getElementById('scale-height').value = maxDim;
                    document.getElementById('scale-width').value = Math.round(maxDim * aspectRatio);
                }
                updateDimensionStyling();

                updateProcessButton();

                if (is16bit) {
                    console.log('Loaded 16-bit image');
                }
            } catch (err) {
                console.error('Failed to load image:', err);
            }
        }

        // Event handlers
        document.getElementById('input-file').addEventListener('change', (e) => handleFile(e.target.files[0]));

        document.getElementById('process-btn').addEventListener('click', processImage);

        // Slider label updates
        function updateBitLabel(channel) {
            const slider = document.getElementById(`bits-${channel}`);
            const label = document.getElementById(`bits-${channel}-label`);
            const bits = parseInt(slider.value);
            if (channel === 'a' && bits === 0) {
                label.textContent = '0 bits (strip alpha)';
            } else {
                const levels = 1 << bits;
                label.textContent = `${bits} bit${bits > 1 ? 's' : ''} (${levels} levels)`;
            }
        }

        ['r', 'g', 'b', 'a', 'gray'].forEach(channel => {
            const handler = () => {
                updateBitLabel(channel);
                // Update alpha dither mode visibility when alpha bits change
                if (channel === 'a') {
                    updateAlphaControlVisibility();
                }
            };
            document.getElementById(`bits-${channel}`).addEventListener('input', handler);
        });

        // Grayscale alpha slider
        document.getElementById('bits-gray-alpha').addEventListener('input', () => {
            updateBitLabel('gray-alpha');
            updateAlphaControlVisibility();
        });

        // Output mode dropdown (RGB / Grayscale / Paletted)
        function updateOutputMode() {
            const outputMode = document.getElementById('output-mode').value;
            const isGrayscale = outputMode === 'grayscale';
            const isPaletted = outputMode.startsWith('palette-');
            const isRgb = outputMode === 'rgb';

            // Toggle visibility of bit depth options
            document.getElementById('rgb-options').classList.toggle('hidden', !isRgb);
            document.getElementById('grayscale-options').classList.toggle('active', isGrayscale);

            // Hide alpha dither mode for paletted (alpha is integrated into main dithering)
            const alphaDitherRow = document.getElementById('alpha-dither-mode-row');
            if (isPaletted) {
                alphaDitherRow.classList.add('hidden');
            }

            // Update alpha visibility
            updateAlphaControlVisibility();
        }

        document.getElementById('output-mode').addEventListener('change', updateOutputMode);

        // Alpha channel control visibility
        function updateAlphaControlVisibility() {
            const outputMode = document.getElementById('output-mode').value;
            const isGrayscale = outputMode === 'grayscale';
            const isPaletted = outputMode.startsWith('palette-');
            const isRgb = outputMode === 'rgb';

            const showRgbAlpha = inputHasAlpha && isRgb;
            const showGrayAlpha = inputHasAlpha && isGrayscale;
            const alphaBox = document.getElementById('alpha-channel-box');
            const grayAlphaBox = document.getElementById('grayscale-alpha-box');
            const rgbOptions = document.getElementById('rgb-options');
            const alphaDitherRow = document.getElementById('alpha-dither-mode-row');

            alphaBox.style.display = showRgbAlpha ? 'block' : 'none';
            grayAlphaBox.style.display = showGrayAlpha ? 'block' : 'none';
            rgbOptions.classList.toggle('has-alpha', showRgbAlpha);

            // Show alpha dither mode when output will have alpha (not for paletted mode)
            // Check if alpha bits > 0 for the current mode (RGB or grayscale)
            // For paletted mode, alpha is always integrated (no separate alpha dither)
            const hasAlphaOutput = isPaletted
                ? false  // Paletted mode: alpha integrated, no separate dither mode
                : isGrayscale
                    ? (showGrayAlpha && parseInt(document.getElementById('bits-gray-alpha').value) > 0)
                    : (showRgbAlpha && parseInt(document.getElementById('bits-a').value) > 0);
            alphaDitherRow.classList.toggle('hidden', !hasAlphaOutput);
        }

        // HDR options visibility (tonemapping + supersampling)
        function updateHdrOptionsVisibility() {
            const hdrOptions = document.getElementById('hdr-options');
            const tonemappingSelect = document.getElementById('tonemapping');
            const supersampleRow = document.getElementById('supersample-row');
            const supersampleSelect = document.getElementById('supersample');

            // Show HDR options only for HDR (f32) images
            hdrOptions.style.display = inputIsHdr ? 'block' : 'none';

            // Reset selections when hiding
            if (!inputIsHdr) {
                tonemappingSelect.value = 'none';
                supersampleSelect.value = 'none';
                supersampleRow.style.display = 'none';
            }
        }

        // Update supersample visibility based on tonemapping selection
        function updateSupersampleVisibility() {
            const tonemapping = document.getElementById('tonemapping').value;
            const supersampleRow = document.getElementById('supersample-row');
            const supersampleSelect = document.getElementById('supersample');

            // Show supersampling only when tonemapping is active
            const showSupersample = tonemapping !== 'none';
            supersampleRow.style.display = showSupersample ? 'flex' : 'none';

            // Reset supersample when hiding
            if (!showSupersample) {
                supersampleSelect.value = 'none';
            }
        }

        document.getElementById('tonemapping').addEventListener('change', updateSupersampleVisibility);

        // Color space aware toggle
        function updatePerceptualMode() {
            const isPerceptual = document.getElementById('perceptual-toggle').checked;
            document.getElementById('perceptual-options').classList.toggle('visible', isPerceptual);
            // Dither mode is now available for both basic and color-space aware modes
            updateSeedVisibility();
            // Color space aware now works with grayscale mode, no need to disable it
        }

        document.getElementById('perceptual-toggle').addEventListener('change', updatePerceptualMode);

        // Downscale toggle
        function updateDownscaleVisibility() {
            const doDownscale = document.getElementById('downscale-toggle').checked;
            document.getElementById('scale-options').classList.toggle('visible', doDownscale);
        }

        document.getElementById('downscale-toggle').addEventListener('change', updateDownscaleVisibility);

        // Upscale toggle
        function updateUpscaleVisibility() {
            const doUpscale = document.getElementById('upscale-toggle').checked;
            document.getElementById('upscale-options').classList.toggle('visible', doUpscale);
        }

        document.getElementById('upscale-toggle').addEventListener('change', updateUpscaleVisibility);

        // Size input handlers (maintain aspect ratio)
        document.getElementById('scale-width').addEventListener('input', updateSizeFromWidth);
        document.getElementById('scale-height').addEventListener('input', updateSizeFromHeight);

        // Show/hide seed options based on dither mode (only for mixed modes 4, 5, 6)
        // Now works for both basic and color-space aware modes
        function updateSeedVisibility() {
            const mode = parseInt(document.getElementById('dither-mode').value);
            const isMixedMode = mode >= 4 && mode <= 6;
            document.getElementById('seed-options').classList.toggle('visible', isMixedMode);
        }

        document.getElementById('dither-mode').addEventListener('change', updateSeedVisibility);

        // Drag and drop support
        const uploadBox = document.getElementById('input-upload');

        uploadBox.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadBox.style.borderColor = '#3498db';
            uploadBox.style.background = '#f8f9fa';
        });

        uploadBox.addEventListener('dragleave', (e) => {
            e.preventDefault();
            if (!uploadBox.classList.contains('has-image')) {
                uploadBox.style.borderColor = '#ccc';
                uploadBox.style.background = '';
            }
        });

        uploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadBox.style.borderColor = uploadBox.classList.contains('has-image') ? '#27ae60' : '#ccc';
            uploadBox.style.background = '';

            const file = e.dataTransfer.files[0];
            if (file && (file.type.startsWith('image/') || !file.type)) {
                handleFile(file);
            }
        });

        // Helper to get RGB interleaved data (extracts from RGBA if needed)
        function getRgbInterleaved() {
            if (!lastDitherResult) return null;
            if (lastDitherResult.rgbInterleaved) {
                return lastDitherResult.rgbInterleaved;
            }
            if (lastDitherResult.rgbaInterleaved) {
                // Extract RGB from RGBA (drop alpha channel)
                const rgba = lastDitherResult.rgbaInterleaved;
                const pixelCount = lastDitherResult.width * lastDitherResult.height;
                const rgb = new Uint8Array(pixelCount * 3);
                for (let i = 0; i < pixelCount; i++) {
                    rgb[i * 3] = rgba[i * 4];
                    rgb[i * 3 + 1] = rgba[i * 4 + 1];
                    rgb[i * 3 + 2] = rgba[i * 4 + 2];
                }
                return rgb;
            }
            return null;
        }

        // Raw download handler - stride=1 means packed, stride>1 means row-aligned
        document.getElementById('download-raw-btn').addEventListener('click', () => {
            if (!lastDitherResult) return;

            const format = getFormatString();
            const stride = parseInt(document.getElementById('stride-select').value) || 1;
            const fill = parseInt(document.getElementById('stride-fill-select').value) || 0;
            let rawData;

            // Always use row-aligned output (each row byte-aligned, then optionally padded to stride)
            // This ensures output matches metadata and is compatible with hardware/embedded use
            if (lastDitherResult.isGrayscale && lastDitherResult.hasAlpha) {
                // LA format - grayscale with alpha
                rawData = encode_la_row_aligned_stride_wasm(
                    lastDitherResult.laInterleaved,
                    lastDitherResult.width,
                    lastDitherResult.height,
                    lastDitherResult.bitsR, // luminosity bits stored in bitsR
                    lastDitherResult.bitsA,
                    stride,
                    fill
                );
            } else if (lastDitherResult.isGrayscale) {
                rawData = encode_gray_row_aligned_stride_wasm(
                    lastDitherResult.grayChannel,
                    lastDitherResult.width,
                    lastDitherResult.height,
                    lastDitherResult.bitsR,
                    stride,
                    fill
                );
            } else if (lastDitherResult.hasAlpha) {
                // ARGB format - use RGBA interleaved data
                rawData = encode_argb_row_aligned_stride_wasm(
                    lastDitherResult.rgbaInterleaved,
                    lastDitherResult.width,
                    lastDitherResult.height,
                    lastDitherResult.bitsA,
                    lastDitherResult.bitsR,
                    lastDitherResult.bitsG,
                    lastDitherResult.bitsB,
                    stride,
                    fill
                );
            } else {
                // RGB format
                const rgbData = getRgbInterleaved();
                rawData = encode_rgb_row_aligned_stride_wasm(
                    rgbData,
                    lastDitherResult.width,
                    lastDitherResult.height,
                    lastDitherResult.bitsR,
                    lastDitherResult.bitsG,
                    lastDitherResult.bitsB,
                    stride,
                    fill
                );
            }

            const blob = new Blob([rawData], { type: 'application/octet-stream' });
            const strideSuffix = stride > 1 ? `_stride${stride}` : '';
            const filename = generateDownloadFilename(lastDitherResult.width, lastDitherResult.height, format + strideSuffix, 'raw');
            downloadBlob(blob, filename);
        });

        document.getElementById('download-meta-btn').addEventListener('click', () => {
            const metadata = generateMetadata();
            if (!metadata) return;

            const format = getFormatString();
            const json = JSON.stringify(metadata, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const filename = generateDownloadFilename(lastDitherResult.width, lastDitherResult.height, format, 'json');
            downloadBlob(blob, filename);
        });

        // PNG download handler - uses palettized encoding by default when format supports it
        document.getElementById('download-btn').addEventListener('click', () => {
            if (!lastDitherResult) return;

            const format = getFormatString();
            const supportsPalettized = format_supports_palettized_wasm(format);
            let pngData;

            try {
                if (supportsPalettized) {
                    // Use palettized PNG for smaller file size (format ≤8 bits)
                    if (lastDitherResult.isGrayscale && lastDitherResult.hasAlpha) {
                        pngData = encode_palettized_png_wasm(
                            lastDitherResult.laInterleaved,
                            format,
                            lastDitherResult.width,
                            lastDitherResult.height
                        );
                    } else if (lastDitherResult.isGrayscale) {
                        pngData = encode_palettized_png_wasm(
                            lastDitherResult.grayChannel,
                            format,
                            lastDitherResult.width,
                            lastDitherResult.height
                        );
                    } else if (lastDitherResult.hasAlpha) {
                        pngData = encode_palettized_png_wasm(
                            lastDitherResult.rgbaInterleaved,
                            format,
                            lastDitherResult.width,
                            lastDitherResult.height
                        );
                    } else {
                        const rgbData = getRgbInterleaved();
                        pngData = encode_palettized_png_wasm(
                            rgbData,
                            format,
                            lastDitherResult.width,
                            lastDitherResult.height
                        );
                    }
                } else {
                    // Use regular PNG encoding for larger formats
                    if (lastDitherResult.isGrayscale && lastDitherResult.hasAlpha) {
                        // LA format - grayscale with alpha
                        pngData = encode_png_gray_alpha_wasm(
                            lastDitherResult.laInterleaved,
                            lastDitherResult.width,
                            lastDitherResult.height
                        );
                    } else if (lastDitherResult.isGrayscale) {
                        pngData = encode_png_gray_wasm(
                            lastDitherResult.grayChannel,
                            lastDitherResult.width,
                            lastDitherResult.height
                        );
                    } else if (lastDitherResult.hasAlpha) {
                        pngData = encode_png_rgba_wasm(
                            lastDitherResult.rgbaInterleaved,
                            lastDitherResult.width,
                            lastDitherResult.height
                        );
                    } else {
                        const rgbData = getRgbInterleaved();
                        pngData = encode_png_rgb_wasm(
                            rgbData,
                            lastDitherResult.width,
                            lastDitherResult.height
                        );
                    }
                }

                const blob = new Blob([pngData], { type: 'image/png' });
                const filename = generateDownloadFilename(lastDitherResult.width, lastDitherResult.height, format, 'png');
                downloadBlob(blob, filename);
            } catch (e) {
                console.error('Failed to generate PNG:', e);
                alert('Failed to generate PNG: ' + e.message);
            }
        });

        // Per-channel download handler helper - respects stride setting
        // channel: 0=R, 1=G, 2=B
        function downloadChannel(channelName, channelIndex, bits) {
            const rgbData = getRgbInterleaved();
            if (!lastDitherResult || !rgbData) return;

            const stride = parseInt(document.getElementById('stride-select').value) || 1;
            const fill = parseInt(document.getElementById('stride-fill-select').value) || 0;

            const rawData = encode_channel_row_aligned_stride_wasm(
                rgbData,
                lastDitherResult.width,
                lastDitherResult.height,
                3,  // num_channels (RGB)
                channelIndex,
                bits,
                stride,
                fill
            );

            const blob = new Blob([rawData], { type: 'application/octet-stream' });
            const strideSuffix = stride > 1 ? `_stride${stride}` : '';
            const filename = generateDownloadFilename(lastDitherResult.width, lastDitherResult.height, `${channelName}${bits}${strideSuffix}`, 'raw');
            downloadBlob(blob, filename);
        }

        // Download alpha channel - uses RGBA interleaved data
        function downloadAlphaChannel() {
            if (!lastDitherResult || !lastDitherResult.rgbaInterleaved || !lastDitherResult.hasAlpha) return;

            const stride = parseInt(document.getElementById('stride-select').value) || 1;
            const fill = parseInt(document.getElementById('stride-fill-select').value) || 0;
            const bits = lastDitherResult.bitsA || 8;

            const rawData = encode_channel_row_aligned_stride_wasm(
                lastDitherResult.rgbaInterleaved,
                lastDitherResult.width,
                lastDitherResult.height,
                4,  // num_channels (RGBA)
                3,  // channel_index (A is at index 3)
                bits,
                stride,
                fill
            );

            const blob = new Blob([rawData], { type: 'application/octet-stream' });
            const strideSuffix = stride > 1 ? `_stride${stride}` : '';
            const filename = generateDownloadFilename(lastDitherResult.width, lastDitherResult.height, `A${bits}${strideSuffix}`, 'raw');
            downloadBlob(blob, filename);
        }

        document.getElementById('download-r-btn').addEventListener('click', () =>
            downloadChannel('R', 0, lastDitherResult?.bitsR));
        document.getElementById('download-g-btn').addEventListener('click', () =>
            downloadChannel('G', 1, lastDitherResult?.bitsG));
        document.getElementById('download-b-btn').addEventListener('click', () =>
            downloadChannel('B', 2, lastDitherResult?.bitsB));
        document.getElementById('download-a-btn').addEventListener('click', () =>
            downloadAlphaChannel());

        // Initialize
        initWasm();
    </script>
</body>
</html>
