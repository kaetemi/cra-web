//! Derived color space constants.
//!
//! THIS FILE IS AUTO-GENERATED by gen_colorspace_derived.
//! Do not edit manually. Regenerate with:
//!   cargo run --manifest-path tools/gen_colorspace_derived/Cargo.toml > src/colorspace_derived.rs
//!
//! All constants are computed from primary constants at f64 precision.

// =============================================================================
// ILLUMINANT XYZ (derived from xy chromaticity, Y=1)
// =============================================================================

/// D65 standard illuminant XYZ (Y=1).
/// Derived from D65 xy chromaticity (0.3127, 0.3290).
pub mod d65_xyz {
    pub const X: f64 = 0.95045592705167159;
    pub const Y: f64 = 1.0;
    pub const Z: f64 = 1.08905775075987843;
}

/// D50 standard illuminant XYZ (Y=1).
/// Derived from D50 xy chromaticity (0.3457, 0.3585).
pub mod d50_xyz {
    pub const X: f64 = 0.96429567642956771;
    pub const Y: f64 = 1.0;
    pub const Z: f64 = 0.82510460251046025;
}

// =============================================================================
// sRGB / Rec.709 MATRICES
// =============================================================================

/// Linear sRGB → XYZ matrix.
/// These 4-digit coefficients are canonical per IEC 61966-2-1.
/// Row-major: result[row] = dot(matrix[row], rgb)
pub const SRGB_TO_XYZ: [[f64; 3]; 3] = [
    [0.4124, 0.3576, 0.1805],
    [0.2126, 0.7152, 0.0722],
    [0.0193, 0.1192, 0.9505],
];

/// XYZ → Linear sRGB matrix (derived inverse).
pub const XYZ_TO_SRGB: [[f64; 3]; 3] = [
    [3.24062547732005291, -1.53720797221031846, -0.49862859869824766],
    [-0.96893071472931924, 1.87575606088524105, 0.04151752384295395],
    [0.05571012044551060, -0.20402105059848666, 1.05699594225438798],
];

/// sRGB chromaticities derived from XYZ matrix columns.
/// x = X/(X+Y+Z), y = Y/(X+Y+Z) for each primary.
pub mod srgb_chromaticity {
    pub const RED_X: f64 = 0.64007449945677475;
    pub const RED_Y: f64 = 0.32997051063169336;
    pub const GREEN_X: f64 = 0.3;
    pub const GREEN_Y: f64 = 0.6;
    pub const BLUE_X: f64 = 0.15001662234042551;
    pub const BLUE_Y: f64 = 0.06000664893617021;
}

// =============================================================================
// APPLE RGB MATRICES
// =============================================================================

/// Linear Apple RGB → XYZ matrix.
pub const APPLE_RGB_TO_XYZ: [[f64; 3]; 3] = [
    [0.44966162221556277, 0.31625611826990330, 0.18453818656620571],
    [0.24461592248526617, 0.67204425132354439, 0.08333982619118969],
    [0.02518105084407150, 0.14118576708477823, 0.92269093283102854],
];

/// XYZ → Linear Apple RGB matrix.
pub const XYZ_TO_APPLE_RGB: [[f64; 3]; 3] = [
    [2.95197847969455207, -1.28960430406109050, -0.47391530718500535],
    [-1.08508357443367731, 1.99080933911131841, 0.03720167780571314],
    [0.08547221373222354, -0.26942971179950037, 1.09102766940544083],
];

// =============================================================================
// DISPLAY P3 MATRICES
// =============================================================================

/// Linear Display P3 → XYZ matrix.
pub const DISPLAY_P3_TO_XYZ: [[f64; 3]; 3] = [
    [0.48657094864821604, 0.26566769316909306, 0.19821728523436249],
    [0.22897456406974873, 0.69173852183650630, 0.07928691409374500],
    [-0.00000000000000004, 0.04511338185890263, 1.04394436890097597],
];

/// XYZ → Linear Display P3 matrix.
pub const XYZ_TO_DISPLAY_P3: [[f64; 3]; 3] = [
    [2.49349691194142631, -0.93138361791912427, -0.40271078445071695],
    [-0.82948896956157481, 1.76266406031834677, 0.02362468584194360],
    [0.03584583024378447, -0.07617238926804180, 0.95688452400768731],
];

// =============================================================================
// ADOBE RGB MATRICES
// =============================================================================

/// Linear Adobe RGB → XYZ matrix.
pub const ADOBE_RGB_TO_XYZ: [[f64; 3]; 3] = [
    [0.57666904291013055, 0.18555823790654630, 0.18822864623499466],
    [0.29734497525053605, 0.62736356625546608, 0.07529145849399786],
    [0.02703136138641234, 0.07068885253582723, 0.99133753683763859],
];

/// XYZ → Linear Adobe RGB matrix.
pub const XYZ_TO_ADOBE_RGB: [[f64; 3]; 3] = [
    [2.04158790381074695, -0.56500697427885971, -0.34473135077832967],
    [-0.96924363628087984, 1.87596750150772063, 0.04155505740717561],
    [0.01344428063203115, -0.11836239223101841, 1.01517499439120584],
];

// =============================================================================
// PROPHOTO RGB MATRICES (D50 white point)
// =============================================================================

/// Linear ProPhoto RGB → XYZ matrix.
/// Note: Uses D50 white point, not D65.
pub const PROPHOTO_RGB_TO_XYZ: [[f64; 3]; 3] = [
    [0.79776048967230262, 0.13518583717574031, 0.03134934958152480],
    [0.28807112822929337, 0.71184321781010140, 0.00008565396060526],
    [0.0, 0.0, 0.82510460251046014],
];

/// XYZ → Linear ProPhoto RGB matrix.
pub const XYZ_TO_PROPHOTO_RGB: [[f64; 3]; 3] = [
    [1.34579897310282814, -0.25558010007997539, -0.05110628506753401],
    [-0.54462249390283457, 1.50823274131327811, 0.02053603239147972],
    [0.0, 0.0, 1.21196754563894538],
];

// =============================================================================
// REC.2020 MATRICES
// =============================================================================

/// Linear Rec.2020 → XYZ matrix.
pub const REC2020_TO_XYZ: [[f64; 3]; 3] = [
    [0.63695804830129110, 0.14461690358620835, 0.16888097516417208],
    [0.26270021201126698, 0.67799807151887093, 0.05930171646986195],
    [0.00000000000000005, 0.02807269304908743, 1.06098505771079088],
];

/// XYZ → Linear Rec.2020 matrix.
pub const XYZ_TO_REC2020: [[f64; 3]; 3] = [
    [1.71665118797126826, -0.35567078377639255, -0.25336628137365985],
    [-0.66668435183248920, 1.61648123663493926, 0.01576854581391114],
    [0.01763985744531079, -0.04277061325780853, 0.94210312123547391],
];

// =============================================================================
// CIELAB DERIVED CONSTANTS
// =============================================================================

/// CIELAB constants derived from δ = 6/29.
pub mod cielab {
    /// δ = 6/29
    pub const DELTA: f64 = 0.20689655172413793;

    /// ε = δ³ = (6/29)³ ≈ 0.008856
    /// Threshold for f(t): if t > EPSILON, use cube root.
    pub const EPSILON: f64 = 0.00885645167903563;

    /// κ = (29/6)² / 3 ≈ 7.787
    /// Linear segment slope: f(t) = κ*t + 16/116 for t ≤ ε
    pub const KAPPA: f64 = 7.78703703703703631;

    /// Linear segment offset = 16/116 = 4/29
    pub const OFFSET: f64 = 0.13793103448275862;

    /// Threshold in f-space for inverse: f(ε) = δ = 6/29
    /// If f > F_THRESHOLD, use cube; otherwise use linear inverse.
    pub const F_THRESHOLD: f64 = 0.20689655172413793;
}

// =============================================================================
// TRANSFER FUNCTION DERIVED CONSTANTS
// =============================================================================

/// sRGB decode threshold in encoded space.
/// sRGB specification threshold (0.0031308) * linear_slope (12.92)
pub const SRGB_DECODE_THRESHOLD: f64 = 0.040449936;

/// Adobe RGB gamma: 563/256
pub const ADOBE_RGB_GAMMA: f64 = 2.19921875;

/// ProPhoto RGB linear segment threshold: 1/512
pub const PROPHOTO_THRESHOLD: f64 = 0.001953125;

/// ProPhoto RGB decode threshold in encoded space: 16 * (1/512)
pub const PROPHOTO_DECODE_THRESHOLD: f64 = 0.03125;

// =============================================================================
// Y'CbCr BT.709 DERIVED CONSTANTS
// =============================================================================

/// Cb channel scaling factor: 2(1-Kb)
pub const YCBCR_CB_SCALE: f64 = 1.8556;

/// Cr channel scaling factor: 2(1-Kr)
pub const YCBCR_CR_SCALE: f64 = 1.5748;

/// RGB' → Y'CbCr matrix (BT.709).
/// Y' = Kr*R' + Kg*G' + Kb*B'
/// Cb = 0.5*(B'-Y')/(1-Kb)
/// Cr = 0.5*(R'-Y')/(1-Kr)
pub const RGB_TO_YCBCR: [[f64; 3]; 3] = [
    [0.2126, 0.7152, 0.0722],
    [-0.11457210605733996, -0.38542789394266003, 0.5],
    [0.5, -0.45415290830581656, -0.04584709169418339],
];

/// Y'CbCr → RGB' matrix (BT.709).
pub const YCBCR_TO_RGB: [[f64; 3]; 3] = [
    [1.0, 0.0, 1.5748],
    [1.0, -0.18732427293064879, -0.46812427293064884],
    [1.0, 1.8556, 0.0],
];

// =============================================================================
// f32 VERSIONS FOR RUNTIME USE
// =============================================================================

/// f32 module for runtime use. All values derived from f64 constants.
pub mod f32 {

    // -------------------------------------------------------------------------
    // ILLUMINANT XYZ
    // -------------------------------------------------------------------------

    pub const D65_X: f32 = 0.95045592705167159 as f32;
    pub const D65_Y: f32 = 1.0 as f32;
    pub const D65_Z: f32 = 1.08905775075987843 as f32;
    pub const D65_XYZ: [f32; 3] = [D65_X, D65_Y, D65_Z];

    pub const D50_X: f32 = 0.96429567642956771 as f32;
    pub const D50_Y: f32 = 1.0 as f32;
    pub const D50_Z: f32 = 0.82510460251046025 as f32;
    pub const D50_XYZ: [f32; 3] = [D50_X, D50_Y, D50_Z];

    // -------------------------------------------------------------------------
    // ILLUMINANT CHROMATICITY (from primary constants)
    // -------------------------------------------------------------------------

    pub const D65_CHROMATICITY: [f32; 2] = [0.3127 as f32, 0.329 as f32];
    pub const D50_CHROMATICITY: [f32; 2] = [0.3457 as f32, 0.3585 as f32];

    // -------------------------------------------------------------------------
    // RGB <-> XYZ MATRICES
    // -------------------------------------------------------------------------

    pub const SRGB_TO_XYZ: [[f32; 3]; 3] = [
        [0.4124 as f32, 0.3576 as f32, 0.1805 as f32],
        [0.2126 as f32, 0.7152 as f32, 0.0722 as f32],
        [0.0193 as f32, 0.1192 as f32, 0.9505 as f32],
    ];
    pub const XYZ_TO_SRGB: [[f32; 3]; 3] = [
        [3.24062547732005291 as f32, -1.53720797221031846 as f32, -0.49862859869824766 as f32],
        [-0.96893071472931924 as f32, 1.87575606088524105 as f32, 0.04151752384295395 as f32],
        [0.05571012044551060 as f32, -0.20402105059848666 as f32, 1.05699594225438798 as f32],
    ];

    /// sRGB chromaticities (derived from XYZ matrix)
    pub const SRGB_RED_XY: [f32; 2] = [0.64007449945677475 as f32, 0.32997051063169336 as f32];
    pub const SRGB_GREEN_XY: [f32; 2] = [0.3 as f32, 0.6 as f32];
    pub const SRGB_BLUE_XY: [f32; 2] = [0.15001662234042551 as f32, 0.06000664893617021 as f32];

    pub const APPLE_RGB_TO_XYZ: [[f32; 3]; 3] = [
        [0.44966162221556277 as f32, 0.31625611826990330 as f32, 0.18453818656620571 as f32],
        [0.24461592248526617 as f32, 0.67204425132354439 as f32, 0.08333982619118969 as f32],
        [0.02518105084407150 as f32, 0.14118576708477823 as f32, 0.92269093283102854 as f32],
    ];
    pub const XYZ_TO_APPLE_RGB: [[f32; 3]; 3] = [
        [2.95197847969455207 as f32, -1.28960430406109050 as f32, -0.47391530718500535 as f32],
        [-1.08508357443367731 as f32, 1.99080933911131841 as f32, 0.03720167780571314 as f32],
        [0.08547221373222354 as f32, -0.26942971179950037 as f32, 1.09102766940544083 as f32],
    ];

    pub const DISPLAY_P3_TO_XYZ: [[f32; 3]; 3] = [
        [0.48657094864821604 as f32, 0.26566769316909306 as f32, 0.19821728523436249 as f32],
        [0.22897456406974873 as f32, 0.69173852183650630 as f32, 0.07928691409374500 as f32],
        [-0.00000000000000004 as f32, 0.04511338185890263 as f32, 1.04394436890097597 as f32],
    ];
    pub const XYZ_TO_DISPLAY_P3: [[f32; 3]; 3] = [
        [2.49349691194142631 as f32, -0.93138361791912427 as f32, -0.40271078445071695 as f32],
        [-0.82948896956157481 as f32, 1.76266406031834677 as f32, 0.02362468584194360 as f32],
        [0.03584583024378447 as f32, -0.07617238926804180 as f32, 0.95688452400768731 as f32],
    ];

    pub const ADOBE_RGB_TO_XYZ: [[f32; 3]; 3] = [
        [0.57666904291013055 as f32, 0.18555823790654630 as f32, 0.18822864623499466 as f32],
        [0.29734497525053605 as f32, 0.62736356625546608 as f32, 0.07529145849399786 as f32],
        [0.02703136138641234 as f32, 0.07068885253582723 as f32, 0.99133753683763859 as f32],
    ];
    pub const XYZ_TO_ADOBE_RGB: [[f32; 3]; 3] = [
        [2.04158790381074695 as f32, -0.56500697427885971 as f32, -0.34473135077832967 as f32],
        [-0.96924363628087984 as f32, 1.87596750150772063 as f32, 0.04155505740717561 as f32],
        [0.01344428063203115 as f32, -0.11836239223101841 as f32, 1.01517499439120584 as f32],
    ];

    pub const PROPHOTO_RGB_TO_XYZ: [[f32; 3]; 3] = [
        [0.79776048967230262 as f32, 0.13518583717574031 as f32, 0.03134934958152480 as f32],
        [0.28807112822929337 as f32, 0.71184321781010140 as f32, 0.00008565396060526 as f32],
        [0.0 as f32, 0.0 as f32, 0.82510460251046014 as f32],
    ];
    pub const XYZ_TO_PROPHOTO_RGB: [[f32; 3]; 3] = [
        [1.34579897310282814 as f32, -0.25558010007997539 as f32, -0.05110628506753401 as f32],
        [-0.54462249390283457 as f32, 1.50823274131327811 as f32, 0.02053603239147972 as f32],
        [0.0 as f32, 0.0 as f32, 1.21196754563894538 as f32],
    ];

    pub const REC2020_TO_XYZ: [[f32; 3]; 3] = [
        [0.63695804830129110 as f32, 0.14461690358620835 as f32, 0.16888097516417208 as f32],
        [0.26270021201126698 as f32, 0.67799807151887093 as f32, 0.05930171646986195 as f32],
        [0.00000000000000005 as f32, 0.02807269304908743 as f32, 1.06098505771079088 as f32],
    ];
    pub const XYZ_TO_REC2020: [[f32; 3]; 3] = [
        [1.71665118797126826 as f32, -0.35567078377639255 as f32, -0.25336628137365985 as f32],
        [-0.66668435183248920 as f32, 1.61648123663493926 as f32, 0.01576854581391114 as f32],
        [0.01763985744531079 as f32, -0.04277061325780853 as f32, 0.94210312123547391 as f32],
    ];

    // -------------------------------------------------------------------------
    // TRANSFER FUNCTION CONSTANTS
    // -------------------------------------------------------------------------

    /// sRGB encode threshold (linear space)
    pub const SRGB_THRESHOLD: f32 = 0.0031308 as f32;
    /// sRGB decode threshold (encoded space)
    pub const SRGB_DECODE_THRESHOLD: f32 = 0.040449936 as f32;
    pub const SRGB_LINEAR_SLOPE: f32 = 12.92 as f32;
    pub const SRGB_GAMMA: f32 = 2.4;
    pub const SRGB_SCALE: f32 = 1.055;
    pub const SRGB_OFFSET: f32 = 0.055;

    pub const ADOBE_RGB_GAMMA: f32 = 2.19921875 as f32;
    pub const APPLE_RGB_GAMMA: f32 = 1.8 as f32;

    pub const PROPHOTO_THRESHOLD: f32 = 0.001953125 as f32;
    pub const PROPHOTO_DECODE_THRESHOLD: f32 = 0.03125 as f32;
    pub const PROPHOTO_LINEAR_MULTIPLIER: f32 = 16.0 as f32;
    pub const PROPHOTO_GAMMA: f32 = 1.8 as f32;

    pub const GAMMA_22: f32 = 2.2;

    // -------------------------------------------------------------------------
    // CIELAB CONSTANTS
    // -------------------------------------------------------------------------

    pub const CIELAB_DELTA: f32 = 0.20689655172413793 as f32;
    pub const CIELAB_EPSILON: f32 = 0.00885645167903563 as f32;
    pub const CIELAB_KAPPA: f32 = 7.78703703703703631 as f32;
    pub const CIELAB_OFFSET: f32 = 0.13793103448275862 as f32;
    pub const CIELAB_F_THRESHOLD: f32 = 0.20689655172413793 as f32;
    pub const CIELAB_L_SCALE: f32 = 116.0;
    pub const CIELAB_L_OFFSET: f32 = 16.0;
    pub const CIELAB_A_SCALE: f32 = 500.0;
    pub const CIELAB_B_SCALE: f32 = 200.0;

    // -------------------------------------------------------------------------
    // OKLAB MATRICES (from primary constants)
    // -------------------------------------------------------------------------

    /// OKLab M1: Linear sRGB → LMS
    pub const OKLAB_M1: [[f32; 3]; 3] = [
        [0.4122214708 as f32, 0.5363325363 as f32, 0.0514459929 as f32],
        [0.2119034982 as f32, 0.6806995451 as f32, 0.1073969566 as f32],
        [0.0883024619 as f32, 0.2817188376 as f32, 0.6299787005 as f32],
    ];

    /// OKLab M2: LMS' → Lab
    pub const OKLAB_M2: [[f32; 3]; 3] = [
        [0.2104542553 as f32, 0.793617785 as f32, -0.0040720468 as f32],
        [1.9779984951 as f32, -2.428592205 as f32, 0.4505937099 as f32],
        [0.0259040371 as f32, 0.7827717662 as f32, -0.808675766 as f32],
    ];

    /// OKLab M1_inv: LMS → Linear sRGB
    pub const OKLAB_M1_INV: [[f32; 3]; 3] = [
        [4.0767416621 as f32, -3.3077115913 as f32, 0.2309699292 as f32],
        [-1.2684380046 as f32, 2.6097574011 as f32, -0.3413193965 as f32],
        [-0.0041960863 as f32, -0.7034186147 as f32, 1.707614701 as f32],
    ];

    /// OKLab M2_inv: Lab → LMS'
    pub const OKLAB_M2_INV: [[f32; 3]; 3] = [
        [1.0 as f32, 0.3963377774 as f32, 0.2158037573 as f32],
        [1.0 as f32, -0.1055613458 as f32, -0.0638541728 as f32],
        [1.0 as f32, -0.0894841775 as f32, -1.291485548 as f32],
    ];

    // -------------------------------------------------------------------------
    // Y'CbCr CONSTANTS
    // -------------------------------------------------------------------------

    /// BT.709 luma coefficients
    pub const YCBCR_KR: f32 = 0.2126 as f32;
    pub const YCBCR_KG: f32 = 0.7152 as f32;
    pub const YCBCR_KB: f32 = 0.0722 as f32;
    pub const YCBCR_CB_SCALE: f32 = 1.8556 as f32;
    pub const YCBCR_CR_SCALE: f32 = 1.5748 as f32;

    pub const RGB_TO_YCBCR: [[f32; 3]; 3] = [
        [0.2126 as f32, 0.7152 as f32, 0.0722 as f32],
        [-0.11457210605733996 as f32, -0.38542789394266003 as f32, 0.5 as f32],
        [0.5 as f32, -0.45415290830581656 as f32, -0.04584709169418339 as f32],
    ];
    pub const YCBCR_TO_RGB: [[f32; 3]; 3] = [
        [1.0 as f32, 0.0 as f32, 1.5748 as f32],
        [1.0 as f32, -0.18732427293064879 as f32, -0.46812427293064884 as f32],
        [1.0 as f32, 1.8556 as f32, 0.0 as f32],
    ];

    /// BT.601 luma coefficients
    pub const YCBCR_601_KR: f32 = 0.299;
    pub const YCBCR_601_KG: f32 = 0.587;
    pub const YCBCR_601_KB: f32 = 0.114;

    // -------------------------------------------------------------------------
    // BIT DEPTH
    // -------------------------------------------------------------------------

    pub const UINT8_MAX: f32 = 255.0;
    pub const UINT16_MAX: f32 = 65535.0;
}

// =============================================================================
// TESTS
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    fn mat_mul(a: [[f64; 3]; 3], b: [[f64; 3]; 3]) -> [[f64; 3]; 3] {
        let mut r = [[0.0; 3]; 3];
        for i in 0..3 {
            for j in 0..3 {
                for k in 0..3 {
                    r[i][j] += a[i][k] * b[k][j];
                }
            }
        }
        r
    }

    fn is_identity(m: [[f64; 3]; 3], tol: f64) -> bool {
        for i in 0..3 {
            for j in 0..3 {
                let expected = if i == j { 1.0 } else { 0.0 };
                if (m[i][j] - expected).abs() > tol {
                    return false;
                }
            }
        }
        true
    }

    #[test]
    fn test_srgb_matrices_are_inverses() {
        let product = mat_mul(SRGB_TO_XYZ, XYZ_TO_SRGB);
        assert!(is_identity(product, 1e-10), "SRGB matrices not inverse");
    }

    #[test]
    fn test_apple_matrices_are_inverses() {
        let product = mat_mul(APPLE_RGB_TO_XYZ, XYZ_TO_APPLE_RGB);
        assert!(is_identity(product, 1e-10), "Apple RGB matrices not inverse");
    }

    #[test]
    fn test_p3_matrices_are_inverses() {
        let product = mat_mul(DISPLAY_P3_TO_XYZ, XYZ_TO_DISPLAY_P3);
        assert!(is_identity(product, 1e-10), "Display P3 matrices not inverse");
    }

    #[test]
    fn test_adobe_matrices_are_inverses() {
        let product = mat_mul(ADOBE_RGB_TO_XYZ, XYZ_TO_ADOBE_RGB);
        assert!(is_identity(product, 1e-10), "Adobe RGB matrices not inverse");
    }

    #[test]
    fn test_prophoto_matrices_are_inverses() {
        let product = mat_mul(PROPHOTO_RGB_TO_XYZ, XYZ_TO_PROPHOTO_RGB);
        assert!(is_identity(product, 1e-10), "ProPhoto RGB matrices not inverse");
    }

    #[test]
    fn test_rec2020_matrices_are_inverses() {
        let product = mat_mul(REC2020_TO_XYZ, XYZ_TO_REC2020);
        assert!(is_identity(product, 1e-10), "Rec.2020 matrices not inverse");
    }

    #[test]
    fn test_ycbcr_matrices_are_inverses() {
        let product = mat_mul(RGB_TO_YCBCR, YCBCR_TO_RGB);
        assert!(is_identity(product, 1e-10), "Y'CbCr matrices not inverse");
    }

    #[test]
    fn test_cielab_epsilon() {
        let expected = (6.0_f64 / 29.0).powi(3);
        assert!((cielab::EPSILON - expected).abs() < 1e-15);
    }

    #[test]
    fn test_cielab_kappa() {
        let expected = (29.0_f64 / 6.0).powi(2) / 3.0;
        assert!((cielab::KAPPA - expected).abs() < 1e-12);
    }

    #[test]
    fn test_white_point_maps_to_white() {
        // RGB (1,1,1) should map approximately to D65 white point XYZ.
        // Tolerance is 1e-3 because the 4-digit canonical sRGB matrix
        // is not perfectly consistent with D65 chromaticity.
        let x = SRGB_TO_XYZ[0][0] + SRGB_TO_XYZ[0][1] + SRGB_TO_XYZ[0][2];
        let y = SRGB_TO_XYZ[1][0] + SRGB_TO_XYZ[1][1] + SRGB_TO_XYZ[1][2];
        let z = SRGB_TO_XYZ[2][0] + SRGB_TO_XYZ[2][1] + SRGB_TO_XYZ[2][2];
        assert!((x - d65_xyz::X).abs() < 1e-3, "X: {} vs {}", x, d65_xyz::X);
        assert!((y - d65_xyz::Y).abs() < 1e-3, "Y: {} vs {}", y, d65_xyz::Y);
        assert!((z - d65_xyz::Z).abs() < 1e-3, "Z: {} vs {}", z, d65_xyz::Z);
    }
}
