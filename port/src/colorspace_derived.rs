//! Derived color space constants.
//!
//! THIS FILE IS AUTO-GENERATED by gen_colorspace_derived.
//! Do not edit manually. Regenerate with:
//!   cargo run --manifest-path tools/gen_colorspace_derived/Cargo.toml > src/colorspace_derived.rs
//!
//! All constants are computed from primary constants at f64 precision.

// =============================================================================
// ILLUMINANT XYZ (derived from xy chromaticity, Y=1)
// =============================================================================

/// D65 standard illuminant XYZ (Y=1).
/// Derived from D65 xy chromaticity (0.3127, 0.3290).
pub mod d65_xyz {
    pub const X: f64 = 0.95045592705167159;
    pub const Y: f64 = 1.00000000000000000;
    pub const Z: f64 = 1.08905775075987843;
}

/// D50 standard illuminant XYZ (Y=1).
/// Derived from D50 xy chromaticity (0.3457, 0.3585).
pub mod d50_xyz {
    pub const X: f64 = 0.96429567642956771;
    pub const Y: f64 = 1.00000000000000000;
    pub const Z: f64 = 0.82510460251046025;
}

// =============================================================================
// sRGB / Rec.709 MATRICES
// =============================================================================

/// Linear sRGB → XYZ matrix.
/// Row-major: result[row] = dot(matrix[row], rgb)
pub const SRGB_TO_XYZ: [[f64; 3]; 3] = [
    [0.41239079926595928, 0.35758433938387801, 0.18048078840183429],
    [0.21263900587151024, 0.71516867876775603, 0.07219231536073371],
    [0.01933081871559182, 0.11919477979462598, 0.95053215224966070],
];

/// XYZ → Linear sRGB matrix.
pub const XYZ_TO_SRGB: [[f64; 3]; 3] = [
    [3.24096994190452259, -1.53738317757009391, -0.49861076029300344],
    [-0.96924363628087962, 1.87596750150772040, 0.04155505740717560],
    [0.05563007969699363, -0.20397695888897649, 1.05697151424287838],
];

// =============================================================================
// APPLE RGB MATRICES
// =============================================================================

/// Linear Apple RGB → XYZ matrix.
pub const APPLE_RGB_TO_XYZ: [[f64; 3]; 3] = [
    [0.44966162221556277, 0.31625611826990330, 0.18453818656620571],
    [0.24461592248526617, 0.67204425132354439, 0.08333982619118969],
    [0.02518105084407150, 0.14118576708477823, 0.92269093283102854],
];

/// XYZ → Linear Apple RGB matrix.
pub const XYZ_TO_APPLE_RGB: [[f64; 3]; 3] = [
    [2.95197847969455207, -1.28960430406109050, -0.47391530718500535],
    [-1.08508357443367731, 1.99080933911131841, 0.03720167780571314],
    [0.08547221373222354, -0.26942971179950037, 1.09102766940544083],
];

// =============================================================================
// DISPLAY P3 MATRICES
// =============================================================================

/// Linear Display P3 → XYZ matrix.
pub const DISPLAY_P3_TO_XYZ: [[f64; 3]; 3] = [
    [0.48657094864821604, 0.26566769316909306, 0.19821728523436249],
    [0.22897456406974873, 0.69173852183650630, 0.07928691409374500],
    [-0.00000000000000004, 0.04511338185890263, 1.04394436890097597],
];

/// XYZ → Linear Display P3 matrix.
pub const XYZ_TO_DISPLAY_P3: [[f64; 3]; 3] = [
    [2.49349691194142631, -0.93138361791912427, -0.40271078445071695],
    [-0.82948896956157481, 1.76266406031834677, 0.02362468584194360],
    [0.03584583024378447, -0.07617238926804180, 0.95688452400768731],
];

// =============================================================================
// ADOBE RGB MATRICES
// =============================================================================

/// Linear Adobe RGB → XYZ matrix.
pub const ADOBE_RGB_TO_XYZ: [[f64; 3]; 3] = [
    [0.57666904291013055, 0.18555823790654630, 0.18822864623499466],
    [0.29734497525053605, 0.62736356625546608, 0.07529145849399786],
    [0.02703136138641234, 0.07068885253582723, 0.99133753683763859],
];

/// XYZ → Linear Adobe RGB matrix.
pub const XYZ_TO_ADOBE_RGB: [[f64; 3]; 3] = [
    [2.04158790381074695, -0.56500697427885971, -0.34473135077832967],
    [-0.96924363628087984, 1.87596750150772063, 0.04155505740717561],
    [0.01344428063203115, -0.11836239223101841, 1.01517499439120584],
];

// =============================================================================
// PROPHOTO RGB MATRICES (D50 white point)
// =============================================================================

/// Linear ProPhoto RGB → XYZ matrix.
/// Note: Uses D50 white point, not D65.
pub const PROPHOTO_RGB_TO_XYZ: [[f64; 3]; 3] = [
    [0.79776048967230262, 0.13518583717574031, 0.03134934958152480],
    [0.28807112822929337, 0.71184321781010140, 0.00008565396060526],
    [0.00000000000000000, 0.00000000000000000, 0.82510460251046014],
];

/// XYZ → Linear ProPhoto RGB matrix.
pub const XYZ_TO_PROPHOTO_RGB: [[f64; 3]; 3] = [
    [1.34579897310282814, -0.25558010007997539, -0.05110628506753401],
    [-0.54462249390283457, 1.50823274131327811, 0.02053603239147972],
    [0.00000000000000000, 0.00000000000000000, 1.21196754563894538],
];

// =============================================================================
// REC.2020 MATRICES
// =============================================================================

/// Linear Rec.2020 → XYZ matrix.
pub const REC2020_TO_XYZ: [[f64; 3]; 3] = [
    [0.63695804830129110, 0.14461690358620835, 0.16888097516417208],
    [0.26270021201126698, 0.67799807151887093, 0.05930171646986195],
    [0.00000000000000005, 0.02807269304908743, 1.06098505771079088],
];

/// XYZ → Linear Rec.2020 matrix.
pub const XYZ_TO_REC2020: [[f64; 3]; 3] = [
    [1.71665118797126826, -0.35567078377639255, -0.25336628137365985],
    [-0.66668435183248920, 1.61648123663493926, 0.01576854581391114],
    [0.01763985744531079, -0.04277061325780853, 0.94210312123547391],
];

// =============================================================================
// CIELAB DERIVED CONSTANTS
// =============================================================================

/// CIELAB constants derived from δ = 6/29.
pub mod cielab {
    /// δ = 6/29
    pub const DELTA: f64 = 0.20689655172413793;

    /// ε = δ³ = (6/29)³ ≈ 0.008856
    /// Threshold for f(t): if t > EPSILON, use cube root.
    pub const EPSILON: f64 = 0.00885645167903563;

    /// κ = (29/6)² / 3 ≈ 7.787
    /// Linear segment slope: f(t) = κ*t + 16/116 for t ≤ ε
    pub const KAPPA: f64 = 7.78703703703703631;

    /// Linear segment offset = 16/116 = 4/29
    pub const OFFSET: f64 = 0.13793103448275862;

    /// Threshold in f-space for inverse: f(ε) = δ = 6/29
    /// If f > F_THRESHOLD, use cube; otherwise use linear inverse.
    pub const F_THRESHOLD: f64 = 0.20689655172413793;
}

// =============================================================================
// TRANSFER FUNCTION DERIVED CONSTANTS
// =============================================================================

/// sRGB decode threshold in encoded space.
/// sRGB specification threshold (0.0031308) * linear_slope (12.92)
pub const SRGB_DECODE_THRESHOLD: f64 = 0.04044993600000000;

/// Adobe RGB gamma: 563/256
pub const ADOBE_RGB_GAMMA: f64 = 2.19921875000000000;

/// ProPhoto RGB linear segment threshold: 1/512
pub const PROPHOTO_THRESHOLD: f64 = 0.00195312500000000;

/// ProPhoto RGB decode threshold in encoded space: 16 * (1/512)
pub const PROPHOTO_DECODE_THRESHOLD: f64 = 0.03125000000000000;

// =============================================================================
// Y'CbCr BT.709 DERIVED CONSTANTS
// =============================================================================

/// Cb channel scaling factor: 2(1-Kb)
pub const YCBCR_CB_SCALE: f64 = 1.85559999999999992;

/// Cr channel scaling factor: 2(1-Kr)
pub const YCBCR_CR_SCALE: f64 = 1.57479999999999998;

/// RGB' → Y'CbCr matrix (BT.709).
/// Y' = Kr*R' + Kg*G' + Kb*B'
/// Cb = 0.5*(B'-Y')/(1-Kb)
/// Cr = 0.5*(R'-Y')/(1-Kr)
pub const RGB_TO_YCBCR: [[f64; 3]; 3] = [
    [0.21260000000000001, 0.71519999999999995, 0.07220000000000000],
    [-0.11457210605733996, -0.38542789394266003, 0.50000000000000000],
    [0.50000000000000000, -0.45415290830581656, -0.04584709169418339],
];

/// Y'CbCr → RGB' matrix (BT.709).
pub const YCBCR_TO_RGB: [[f64; 3]; 3] = [
    [1.00000000000000000, 0.00000000000000000, 1.57479999999999998],
    [1.00000000000000000, -0.18732427293064879, -0.46812427293064884],
    [1.00000000000000000, 1.85559999999999992, 0.00000000000000000],
];

// =============================================================================
// f32 VERSIONS FOR RUNTIME USE
// =============================================================================

/// sRGB → XYZ matrix as f32.
pub const SRGB_TO_XYZ_F32: [[f32; 3]; 3] = [
    [0.41239079926595928 as f32, 0.35758433938387801 as f32, 0.18048078840183429 as f32],
    [0.21263900587151024 as f32, 0.71516867876775603 as f32, 0.07219231536073371 as f32],
    [0.01933081871559182 as f32, 0.11919477979462598 as f32, 0.95053215224966070 as f32],
];

/// XYZ → sRGB matrix as f32.
pub const XYZ_TO_SRGB_F32: [[f32; 3]; 3] = [
    [3.24096994190452259 as f32, -1.53738317757009391 as f32, -0.49861076029300344 as f32],
    [-0.96924363628087962 as f32, 1.87596750150772040 as f32, 0.04155505740717560 as f32],
    [0.05563007969699363 as f32, -0.20397695888897649 as f32, 1.05697151424287838 as f32],
];

/// D65 white point XYZ as f32.
pub const D65_XYZ_F32: [f32; 3] = [0.95045592705167159 as f32, 1.00000000000000000 as f32, 1.08905775075987843 as f32];

/// CIELAB epsilon as f32.
pub const CIELAB_EPSILON_F32: f32 = 0.00885645167903563 as f32;

/// CIELAB kappa as f32.
pub const CIELAB_KAPPA_F32: f32 = 7.78703703703703631 as f32;

/// CIELAB offset (16/116) as f32.
pub const CIELAB_OFFSET_F32: f32 = 0.13793103448275862 as f32;

/// CIELAB f-threshold (6/29) as f32.
pub const CIELAB_F_THRESHOLD_F32: f32 = 0.20689655172413793 as f32;

// =============================================================================
// TESTS
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    fn mat_mul(a: [[f64; 3]; 3], b: [[f64; 3]; 3]) -> [[f64; 3]; 3] {
        let mut r = [[0.0; 3]; 3];
        for i in 0..3 {
            for j in 0..3 {
                for k in 0..3 {
                    r[i][j] += a[i][k] * b[k][j];
                }
            }
        }
        r
    }

    fn is_identity(m: [[f64; 3]; 3], tol: f64) -> bool {
        for i in 0..3 {
            for j in 0..3 {
                let expected = if i == j { 1.0 } else { 0.0 };
                if (m[i][j] - expected).abs() > tol {
                    return false;
                }
            }
        }
        true
    }

    #[test]
    fn test_srgb_matrices_are_inverses() {
        let product = mat_mul(SRGB_TO_XYZ, XYZ_TO_SRGB);
        assert!(is_identity(product, 1e-10), "SRGB matrices not inverse");
    }

    #[test]
    fn test_apple_matrices_are_inverses() {
        let product = mat_mul(APPLE_RGB_TO_XYZ, XYZ_TO_APPLE_RGB);
        assert!(is_identity(product, 1e-10), "Apple RGB matrices not inverse");
    }

    #[test]
    fn test_p3_matrices_are_inverses() {
        let product = mat_mul(DISPLAY_P3_TO_XYZ, XYZ_TO_DISPLAY_P3);
        assert!(is_identity(product, 1e-10), "Display P3 matrices not inverse");
    }

    #[test]
    fn test_adobe_matrices_are_inverses() {
        let product = mat_mul(ADOBE_RGB_TO_XYZ, XYZ_TO_ADOBE_RGB);
        assert!(is_identity(product, 1e-10), "Adobe RGB matrices not inverse");
    }

    #[test]
    fn test_prophoto_matrices_are_inverses() {
        let product = mat_mul(PROPHOTO_RGB_TO_XYZ, XYZ_TO_PROPHOTO_RGB);
        assert!(is_identity(product, 1e-10), "ProPhoto RGB matrices not inverse");
    }

    #[test]
    fn test_rec2020_matrices_are_inverses() {
        let product = mat_mul(REC2020_TO_XYZ, XYZ_TO_REC2020);
        assert!(is_identity(product, 1e-10), "Rec.2020 matrices not inverse");
    }

    #[test]
    fn test_ycbcr_matrices_are_inverses() {
        let product = mat_mul(RGB_TO_YCBCR, YCBCR_TO_RGB);
        assert!(is_identity(product, 1e-10), "Y'CbCr matrices not inverse");
    }

    #[test]
    fn test_cielab_epsilon() {
        let expected = (6.0_f64 / 29.0).powi(3);
        assert!((cielab::EPSILON - expected).abs() < 1e-15);
    }

    #[test]
    fn test_cielab_kappa() {
        let expected = (29.0_f64 / 6.0).powi(2) / 3.0;
        assert!((cielab::KAPPA - expected).abs() < 1e-12);
    }

    #[test]
    fn test_white_point_maps_to_white() {
        // RGB (1,1,1) should map to the white point XYZ
        let x = SRGB_TO_XYZ[0][0] + SRGB_TO_XYZ[0][1] + SRGB_TO_XYZ[0][2];
        let y = SRGB_TO_XYZ[1][0] + SRGB_TO_XYZ[1][1] + SRGB_TO_XYZ[1][2];
        let z = SRGB_TO_XYZ[2][0] + SRGB_TO_XYZ[2][1] + SRGB_TO_XYZ[2][2];
        assert!((x - d65_xyz::X).abs() < 1e-10);
        assert!((y - d65_xyz::Y).abs() < 1e-10);
        assert!((z - d65_xyz::Z).abs() < 1e-10);
    }
}
