//! Derived color space constants.
//!
//! THIS FILE IS AUTO-GENERATED by gen_colorspace_derived.
//! Do not edit manually. Regenerate with:
//!   cargo run --manifest-path tools/gen_colorspace_derived/Cargo.toml > src/colorspace_derived.rs
//!
//! All constants are computed from primary constants at f64 precision.

// =============================================================================
// D65 ILLUMINANT
// =============================================================================

/// D65 (4-digit) - authoritative for sRGB, BT.709, Display P3, Adobe RGB, Rec.2020.
///
/// Defined by IEC 61966-2-1, ITU-R BT.709-6.
/// xy chromaticity is authoritative; XYZ is derived.
///
/// All D65 color spaces use this exact white point. Using "more accurate" CIE values
/// (0.31272, 0.32903) would produce non-conforming matrices.
pub mod d65 {
    /// Authoritative chromaticity x coordinate
    pub const X: f64 = 0.3127;
    /// Authoritative chromaticity y coordinate
    pub const Y: f64 = 0.329;
    /// Derived XYZ X (from chromaticity)
    pub const XYZ_X: f64 = 0.9504559270516716;
    /// Derived XYZ Y (normalized to 1.0)
    pub const XYZ_Y: f64 = 1.0;
    /// Derived XYZ Z (from chromaticity)
    pub const XYZ_Z: f64 = 1.0890577507598784;
}

// =============================================================================
// D50 ILLUMINANT
// =============================================================================

/// D50 - authoritative for ProPhoto RGB (ISO 22028-2) and ICC PCS (ICC.1:2022-05).
/// XYZ is authoritative; chromaticity is derived.
pub mod d50 {
    /// Authoritative XYZ X
    pub const XYZ_X: f64 = 0.9642;
    /// Authoritative XYZ Y (normalized to 1.0)
    pub const XYZ_Y: f64 = 1.0;
    /// Authoritative XYZ Z
    pub const XYZ_Z: f64 = 0.8249;
    /// Derived chromaticity x
    pub const X: f64 = 0.345702914918791;
    /// Derived chromaticity y
    pub const Y: f64 = 0.3585385966799326;
}

// =============================================================================
// ILLUMINANT C - 4-DIGIT CHROMATICITY
// =============================================================================

/// CIE Illuminant C - 4-digit chromaticity values.
///
/// Authoritative for: NTSC 1953 (BT.470 M/NTSC).
///
/// These 4-digit values (0.3101, 0.3162) round to the BT.470 specification (0.310, 0.316).
/// CIE 15:2004 gives 5-digit values (0.31006, 0.31616).
/// The resulting NTSC 1953 matrix produces luma coefficients that round to 0.299/0.587/0.114.
///
/// See WHITEPOINT_C.md for full analysis.
pub mod illuminant_c {
    /// Chromaticity x (authoritative)
    pub const X: f64 = 0.3101;
    /// Chromaticity y (authoritative)
    pub const Y: f64 = 0.3162;
    /// XYZ X (derived from chromaticity, Y=1)
    pub const XYZ_X: f64 = 0.980708412397217;
    /// XYZ Y (normalized to 1.0)
    pub const XYZ_Y: f64 = 1.0;
    /// XYZ Z (derived from chromaticity, Y=1)
    pub const XYZ_Z: f64 = 1.1818469323213157;
}

// =============================================================================
// sRGB / Rec.709 MATRICES
// =============================================================================

/// Linear sRGB → XYZ matrix.
///
/// Derived from authoritative chromaticity primaries (IEC 61966-2-1):
///   Red: (0.640, 0.330), Green: (0.300, 0.600), Blue: (0.150, 0.060)
///   White point D65: (0.3127, 0.3290)
///
/// The 4-decimal matrices in IEC 61966-2-1 are truncated for presentation.
/// Per Amendment 1, higher precision is recommended for N > 8 bit depths.
/// Row-major: result[row] = dot(matrix[row], rgb)
pub const SRGB_TO_XYZ: [[f64; 3]; 3] = [
    [0.4123907992659593, 0.357584339383878, 0.1804807884018343],
    [0.21263900587151024, 0.715168678767756, 0.07219231536073371],
    [0.01933081871559182, 0.11919477979462598, 0.9505321522496607],
];

/// XYZ → Linear sRGB matrix (inverse of SRGB_TO_XYZ).
pub const XYZ_TO_SRGB: [[f64; 3]; 3] = [
    [3.2409699419045226, -1.537383177570094, -0.49861076029300344],
    [-0.9692436362808796, 1.8759675015077204, 0.0415550574071756],
    [0.05563007969699363, -0.2039769588889765, 1.0569715142428784],
];

/// sRGB primaries - authoritative chromaticity coordinates from IEC 61966-2-1.
pub mod srgb_primaries {
    pub const RED_X: f64 = 0.64;
    pub const RED_Y: f64 = 0.33;
    pub const GREEN_X: f64 = 0.3;
    pub const GREEN_Y: f64 = 0.6;
    pub const BLUE_X: f64 = 0.15;
    pub const BLUE_Y: f64 = 0.06;
}

// =============================================================================
// APPLE RGB MATRICES
// =============================================================================

/// Linear Apple RGB → XYZ matrix.
pub const APPLE_RGB_TO_XYZ: [[f64; 3]; 3] = [
    [0.4496616222155628, 0.3162561182699033, 0.18453818656620571],
    [0.24461592248526617, 0.6720442513235444, 0.0833398261911897],
    [0.0251810508440715, 0.14118576708477823, 0.9226909328310285],
];

/// XYZ → Linear Apple RGB matrix.
pub const XYZ_TO_APPLE_RGB: [[f64; 3]; 3] = [
    [2.951978479694552, -1.2896043040610905, -0.47391530718500535],
    [-1.0850835744336773, 1.9908093391113184, 0.03720167780571314],
    [0.08547221373222354, -0.26942971179950037, 1.0910276694054408],
];

// =============================================================================
// DISPLAY P3 MATRICES
// =============================================================================

/// Linear Display P3 → XYZ matrix.
pub const DISPLAY_P3_TO_XYZ: [[f64; 3]; 3] = [
    [0.48657094864821604, 0.26566769316909306, 0.1982172852343625],
    [0.22897456406974873, 0.6917385218365063, 0.079286914093745],
    [-0.0, 0.04511338185890263, 1.043944368900976],
];

/// XYZ → Linear Display P3 matrix.
pub const XYZ_TO_DISPLAY_P3: [[f64; 3]; 3] = [
    [2.4934969119414263, -0.9313836179191243, -0.40271078445071695],
    [-0.8294889695615748, 1.7626640603183468, 0.02362468584194360],
    [0.03584583024378447, -0.0761723892680418, 0.9568845240076873],
];

// =============================================================================
// ADOBE RGB MATRICES
// =============================================================================

/// Linear Adobe RGB → XYZ matrix.
pub const ADOBE_RGB_TO_XYZ: [[f64; 3]; 3] = [
    [0.5766690429101305, 0.1855582379065463, 0.18822864623499466],
    [0.29734497525053605, 0.6273635662554661, 0.07529145849399786],
    [0.02703136138641234, 0.07068885253582723, 0.9913375368376386],
];

/// XYZ → Linear Adobe RGB matrix.
pub const XYZ_TO_ADOBE_RGB: [[f64; 3]; 3] = [
    [2.041587903810747, -0.5650069742788597, -0.34473135077832967],
    [-0.9692436362808798, 1.8759675015077206, 0.04155505740717561],
    [0.01344428063203115, -0.11836239223101841, 1.0151749943912058],
];

// =============================================================================
// PROPHOTO RGB MATRICES (D50 white point)
// =============================================================================

/// Linear ProPhoto RGB → XYZ matrix.
/// Note: Uses D50 white point, not D65.
pub const PROPHOTO_RGB_TO_XYZ: [[f64; 3]; 3] = [
    [0.7976661108038989, 0.13519231336302714, 0.03134157583307381],
    [0.28803704804175084, 0.7118773192373937, 0.00008563272085539],
    [0.0, 0.0, 0.8249],
];

/// XYZ → Linear ProPhoto RGB matrix.
pub const XYZ_TO_PROPHOTO_RGB: [[f64; 3]; 3] = [
    [1.3459582063740676, -0.25561034000154825, -0.05111233190002151],
    [-0.5445964045699176, 1.5081604916604545, 0.02053504864330213],
    [0.0, 0.0, 1.2122681537156021],
];

// =============================================================================
// REC.2020 MATRICES
// =============================================================================

/// Linear Rec.2020 → XYZ matrix.
pub const REC2020_TO_XYZ: [[f64; 3]; 3] = [
    [0.6369580483012911, 0.14461690358620835, 0.16888097516417208],
    [0.262700212011267, 0.6779980715188709, 0.05930171646986195],
    [0.0, 0.02807269304908743, 1.0609850577107909],
];

/// XYZ → Linear Rec.2020 matrix.
pub const XYZ_TO_REC2020: [[f64; 3]; 3] = [
    [1.7166511879712683, -0.35567078377639255, -0.25336628137365985],
    [-0.6666843518324892, 1.6164812366349393, 0.01576854581391114],
    [0.01763985744531079, -0.04277061325780853, 0.9421031212354739],
];

/// Linear BT.601 625-line (PAL/SECAM) → XYZ matrix.
pub const BT601_625_TO_XYZ: [[f64; 3]; 3] = [
    [0.4305538133299022, 0.3415498035305534, 0.17835231019121597],
    [0.22200430999823084, 0.706654765925283, 0.07134092407648639],
    [0.02018220999983915, 0.12955337375296855, 0.9393221670070708],
];

/// XYZ → Linear BT.601 625-line (PAL/SECAM) matrix.
pub const XYZ_TO_BT601_625: [[f64; 3]; 3] = [
    [3.0633610900832724, -1.3933901749073678, -0.47582373799753014],
    [-0.9692436362808795, 1.87596750150772, 0.04155505740717561],
    [0.06786104755356688, -0.22879926962049577, 1.0690896180160279],
];

/// Linear BT.601 525-line (NTSC) → XYZ matrix.
pub const BT601_525_TO_XYZ: [[f64; 3]; 3] = [
    [0.39352090365938974, 0.3652580767176036, 0.19167694667467827],
    [0.2123763607050675, 0.7010598569257229, 0.08656378236920956],
    [0.01873909065044711, 0.11193392673603976, 0.9583847333733914],
];

/// XYZ → Linear BT.601 525-line (NTSC) matrix.
pub const XYZ_TO_BT601_525: [[f64; 3]; 3] = [
    [3.506003282724663, -1.7397907263028323, -0.5440582683627413],
    [-1.069047559853815, 1.9777788827287865, 0.03517141933719514],
    [0.0563065917341277, -0.19697565482077187, 1.0499523282187335],
];

/// Original NTSC 1953 (BT.470 M/NTSC) → XYZ matrix.
/// White point: Illuminant C, xy (0.3101, 0.3162), XYZ (0.980708, 1.000000, 1.181847).
/// The Y row rounds to the traditional 0.299/0.587/0.114 values.
pub const NTSC_1953_TO_XYZ: [[f64; 3]; 3] = [
    [0.6069370511550323, 0.17350884116135754, 0.2002625200808271],
    [0.29893914459874726, 0.5866251296407803, 0.11443572576047262],
    [-0.0, 0.06609860615670769, 1.115748326164608],
];

/// XYZ → Original NTSC 1953 (BT.470 M/NTSC) matrix.
pub const XYZ_TO_NTSC_1953: [[f64; 3]; 3] = [
    [1.9098509307175413, -0.5324136865683171, -0.28818722483973136],
    [-0.9846224942838822, 1.999082033849094, -0.02830694039510768],
    [0.05833051498847057, -0.11842862134022794, 0.897936412549787],
];

// =============================================================================
// BRADFORD CHROMATIC ADAPTATION MATRICES
// =============================================================================

// Derived from the Bradford matrix using von Kries adaptation.
// Only needed for D50 ↔ D65 conversion (ProPhoto RGB).
// All D65 color spaces share the same white point, so no adaptation needed between them.

/// Bradford matrix: XYZ → LMS (cone-like response).
/// Primary constant from Lam (1985) and Hunt (1994).
pub const BRADFORD: [[f64; 3]; 3] = [
    [0.8951, 0.2664, -0.1614],
    [-0.7502, 1.7135, 0.0367],
    [0.0389, -0.0685, 1.0296],
];

/// Bradford inverse: LMS → XYZ.
pub const BRADFORD_INV: [[f64; 3]; 3] = [
    [0.9869929054667123, -0.14705425642099013, 0.15996265166373125],
    [0.43230526972339456, 0.5183602715367776, 0.0492912282128556],
    [-0.00852866457517733, 0.04004282165408487, 0.9684866957875502],
];

/// Chromatic adaptation: D50 → D65 (for ProPhoto RGB to D65 spaces).
pub const ADAPT_D50_TO_D65: [[f64; 3]; 3] = [
    [0.9555125889283475, -0.02307297517304352, 0.06330908471330188],
    [-0.02832475931011879, 1.0099429264007957, 0.021054438751389],
    [0.01232870317482127, -0.02053530765430329, 1.330713689917589],
];

/// Chromatic adaptation: D65 → D50 (for D65 spaces to ProPhoto RGB).
pub const ADAPT_D65_TO_D50: [[f64; 3]; 3] = [
    [1.0478860032225505, 0.02291876517477952, -0.05021609531173302],
    [0.02958178249800350, 0.9904835184905488, -0.0170787077044827],
    [-0.00925188083920884, 0.01507260748703133, 0.7516781336176036],
];

// =============================================================================
// DIRECT RGB ↔ sRGB MATRICES
// =============================================================================

// These matrices convert directly between linear RGB spaces.
// D65 spaces share the same white point as sRGB, so no chromatic adaptation needed.
// D50 spaces (ProPhoto) include full Bradford D50↔D65 adaptation.

/// Linear Apple RGB → Linear sRGB matrix.
pub const APPLE_RGB_TO_SRGB: [[f64; 3]; 3] = [
    [1.0687158545276882, -0.07860969598003947, 0.00989384145235139],
    [0.02410625513491821, 0.9600709276463433, 0.01582281721873901],
    [0.00173435335705017, 0.02974114446536134, 0.9685245021775882],
];

/// Linear sRGB → Linear Apple RGB matrix.
pub const SRGB_TO_APPLE_RGB: [[f64; 3]; 3] = [
    [0.9339874165842391, 0.07680843758720021, -0.01079585417143902],
    [-0.02343562489314104, 1.0401898373846301, -0.01675421249148942],
    [-0.00095285344225948, -0.03207936312068568, 1.0330322165629455],
];

/// Linear Display P3 → Linear sRGB matrix.
pub const DISPLAY_P3_TO_SRGB: [[f64; 3]; 3] = [
    [1.2249401762805598, -0.22494017628055996, -0.0],
    [-0.04205695470968812, 1.0420569547096883, 0.0],
    [-0.01963755459033444, -0.0786360455506318, 1.0982736001409663],
];

/// Linear sRGB → Linear Display P3 matrix.
pub const SRGB_TO_DISPLAY_P3: [[f64; 3]; 3] = [
    [0.8224619687143624, 0.17753803128563794, 0.0],
    [0.03319419885096169, 0.9668058011490385, 0.0],
    [0.01708263072112004, 0.07239744066396342, 0.9105199286149166],
];

/// Linear Adobe RGB → Linear sRGB matrix.
pub const ADOBE_RGB_TO_SRGB: [[f64; 3]; 3] = [
    [1.3983557439607786, -0.39835574396077855, 0.0],
    [-0.0, 1.0, -0.0],
    [-0.0, -0.04292898929447317, 1.0429289892944729],
];

/// Linear sRGB → Linear Adobe RGB matrix.
pub const SRGB_TO_ADOBE_RGB: [[f64; 3]; 3] = [
    [0.7151256068556247, 0.28487439314437574, 0.0],
    [-0.0, 1.0, -0.0],
    [0.0, 0.04116194845011842, 0.958838051549882],
];

/// Linear Rec.2020 → Linear sRGB matrix.
pub const REC2020_TO_SRGB: [[f64; 3]; 3] = [
    [1.6604910021084347, -0.5876411387885496, -0.07284986331988486],
    [-0.12455047452159052, 1.13289989712596, -0.00834942260436949],
    [-0.01815076335490522, -0.10057889800800737, 1.1187296613629125],
];

/// Linear sRGB → Linear Rec.2020 matrix.
pub const SRGB_TO_REC2020: [[f64; 3]; 3] = [
    [0.627403895934699, 0.32928303837788375, 0.04331306568741727],
    [0.06909728935823199, 0.919540395075459, 0.01136231556630915],
    [0.01639143887515023, 0.08801330787722578, 0.895595253247624],
];

/// Linear ProPhoto RGB → Linear sRGB matrix (includes D50→D65 adaptation).
pub const PROPHOTO_RGB_TO_SRGB: [[f64; 3]; 3] = [
    [2.0342181530788603, -0.7275364732863576, -0.30668167979250266],
    [-0.22879805605430628, 1.2317302821191265, -0.00293222606482029],
    [-0.00855553292091616, -0.1532865748773777, 1.1618421077982937],
];

/// Linear sRGB → Linear ProPhoto RGB matrix (includes D65→D50 adaptation).
pub const SRGB_TO_PROPHOTO_RGB: [[f64; 3]; 3] = [
    [0.529312458714951, 0.3301361988565311, 0.14055134242851772],
    [0.09836174743191933, 0.8734700897221939, 0.02816816284588725],
    [0.01687499996529928, 0.1176715222416342, 0.865453477793067],
];

// =============================================================================
// CIELAB DERIVED CONSTANTS
// =============================================================================

/// CIELAB constants derived from δ = 6/29.
pub mod cielab {
    /// δ = 6/29
    pub const DELTA: f64 = 0.20689655172413793;

    /// ε = δ³ = (6/29)³ ≈ 0.008856
    /// Threshold for f(t): if t > EPSILON, use cube root.
    pub const EPSILON: f64 = 0.00885645167903563;

    /// κ = (29/6)² / 3 ≈ 7.787
    /// Linear segment slope: f(t) = κ*t + 16/116 for t ≤ ε
    pub const KAPPA: f64 = 7.787037037037036;

    /// Linear segment offset = 16/116 = 4/29
    pub const OFFSET: f64 = 0.13793103448275862;

    /// Threshold in f-space for inverse: f(ε) = δ = 6/29
    /// If f > F_THRESHOLD, use cube; otherwise use linear inverse.
    pub const F_THRESHOLD: f64 = 0.20689655172413793;
}

// =============================================================================
// TRANSFER FUNCTION DERIVED CONSTANTS
// =============================================================================

/// sRGB encode threshold (linear space).
/// Derived from γ=2.4 and offset=0.055 for continuous value AND slope.
/// Spec value is 0.0031308; this derived value rounds to ~0.00304.
pub const SRGB_THRESHOLD: f64 = 0.00303993463977843;

/// sRGB linear segment slope.
/// Derived from γ=2.4 and offset=0.055 for continuous value AND slope.
/// Spec value is 12.92; this derived value is ~12.9232.
pub const SRGB_LINEAR_SLOPE: f64 = 12.92321018078785;

/// sRGB decode threshold (encoded space).
/// = SRGB_THRESHOLD * SRGB_LINEAR_SLOPE (the y-value at the junction).
pub const SRGB_DECODE_THRESHOLD: f64 = 0.03928571428571428;

/// Adobe RGB gamma: 563/256
pub const ADOBE_RGB_GAMMA: f64 = 2.19921875;

/// ProPhoto RGB linear segment threshold: 1/512
pub const PROPHOTO_THRESHOLD: f64 = 0.001953125;

/// ProPhoto RGB decode threshold in encoded space: 16 * (1/512)
pub const PROPHOTO_DECODE_THRESHOLD: f64 = 0.03125;

// =============================================================================
// Y'CbCr BT.709 DERIVED CONSTANTS
// =============================================================================

/// Cb channel scaling factor: 2(1-Kb)
pub const YCBCR_CB_SCALE: f64 = 1.8556153692785327;

/// Cr channel scaling factor: 2(1-Kr)
pub const YCBCR_CR_SCALE: f64 = 1.5747219882569796;

/// RGB' → Y'CbCr matrix (BT.709).
/// Y' = Kr*R' + Kg*G' + Kb*B'
/// Cb = 0.5*(B'-Y')/(1-Kb)
/// Cr = 0.5*(R'-Y')/(1-Kr)
pub const RGB_TO_YCBCR: [[f64; 3]; 3] = [
    [0.21263900587151024, 0.715168678767756, 0.07219231536073371],
    [-0.11459217755573169, -0.3854078224442683, 0.5],
    [0.5, -0.45415551703787305, -0.04584448296212691],
];

/// Y'CbCr → RGB' matrix (BT.709).
pub const YCBCR_TO_RGB: [[f64; 3]; 3] = [
    [1.0, 0.0, 1.5747219882569796],
    [1.0, -0.18731408953478898, -0.46820747055634204],
    [1.0, 1.8556153692785327, 0.0],
];

// =============================================================================
// BT.601 / ITU-T T.871 Y'CbCr ENCODING
// =============================================================================

/// BT.601 Y'CbCr encoding coefficients.
///
/// Used by BT.601 and JPEG (ITU-T T.871). This is an encoding, not a color space:
/// it's applied to whatever RGB data you have, regardless of primaries/white point.
///
/// Coefficients derived by rounding the NTSC 1953 / BT.470 matrix Y row to 3 decimal places.
/// Historically from NTSC 1953 with Illuminant C, but commonly applied to sRGB/BT.709 data.
pub mod bt601_ycbcr {
    /// Kr coefficient (NTSC 1953 Y row rounded to 3 decimal places)
    pub const KR: f64 = 0.299;
    /// Kg coefficient (NTSC 1953 Y row rounded to 3 decimal places)
    pub const KG: f64 = 0.587;
    /// Kb coefficient (NTSC 1953 Y row rounded to 3 decimal places)
    pub const KB: f64 = 0.114;

    /// Cb channel scaling factor: 2(1-Kb) = 1.772
    pub const CB_SCALE: f64 = 1.772;
    /// Cr channel scaling factor: 2(1-Kr) = 1.402
    pub const CR_SCALE: f64 = 1.402;

    // Cb row coefficients: Cb = -0.16873589164785552·R + -0.3312641083521444·G + 0.5·B
    pub const CB_R: f64 = -0.16873589164785552;
    pub const CB_G: f64 = -0.3312641083521444;
    pub const CB_B: f64 = 0.5;

    // Cr row coefficients: Cr = 0.5·R + -0.41868758915834514·G + -0.08131241084165478·B
    pub const CR_R: f64 = 0.5;
    pub const CR_G: f64 = -0.41868758915834514;
    pub const CR_B: f64 = -0.08131241084165478;
}

// =============================================================================
// f32 VERSIONS FOR RUNTIME USE
// =============================================================================

/// f32 module for runtime use. All values derived from f64 constants.
pub mod f32 {

    // -------------------------------------------------------------------------
    // ILLUMINANT XYZ
    // -------------------------------------------------------------------------

    /// D65 XYZ (computed from f32 sRGB matrix row sums for internal consistency)
    pub const D65_X: f32 = 0.9504559;
    pub const D65_Y: f32 = 1.0;
    pub const D65_Z: f32 = 1.0890577;
    pub const D65_XYZ: [f32; 3] = [D65_X, D65_Y, D65_Z];

    /// D50 XYZ (authoritative for ICC/ProPhoto)
    pub const D50_X: f32 = 0.9642 as f32;
    pub const D50_Y: f32 = 1.0 as f32;
    pub const D50_Z: f32 = 0.8249 as f32;
    pub const D50_XYZ: [f32; 3] = [D50_X, D50_Y, D50_Z];

    // -------------------------------------------------------------------------
    // ILLUMINANT CHROMATICITY
    // -------------------------------------------------------------------------

    /// D65 chromaticity (authoritative for display standards)
    pub const D65_CHROMATICITY: [f32; 2] = [0.3127 as f32, 0.329 as f32];
    /// D50 chromaticity (derived from authoritative XYZ)
    pub const D50_CHROMATICITY: [f32; 2] = [0.345702914918791 as f32, 0.3585385966799326 as f32];

    // -------------------------------------------------------------------------
    // RGB <-> XYZ MATRICES
    // -------------------------------------------------------------------------

    pub const SRGB_TO_XYZ: [[f32; 3]; 3] = [
        [0.4123907992659593 as f32, 0.357584339383878 as f32, 0.1804807884018343 as f32],
        [0.21263900587151024 as f32, 0.715168678767756 as f32, 0.07219231536073371 as f32],
        [0.01933081871559182 as f32, 0.11919477979462598 as f32, 0.9505321522496607 as f32],
    ];
    pub const XYZ_TO_SRGB: [[f32; 3]; 3] = [
        [3.2409699419045226 as f32, -1.537383177570094 as f32, -0.49861076029300344 as f32],
        [-0.9692436362808796 as f32, 1.8759675015077204 as f32, 0.0415550574071756 as f32],
        [0.05563007969699363 as f32, -0.2039769588889765 as f32, 1.0569715142428784 as f32],
    ];

    /// sRGB primaries (authoritative chromaticity coordinates)
    pub const SRGB_RED_XY: [f32; 2] = [0.64 as f32, 0.33 as f32];
    pub const SRGB_GREEN_XY: [f32; 2] = [0.3 as f32, 0.6 as f32];
    pub const SRGB_BLUE_XY: [f32; 2] = [0.15 as f32, 0.06 as f32];

    pub const APPLE_RGB_TO_XYZ: [[f32; 3]; 3] = [
        [0.4496616222155628 as f32, 0.3162561182699033 as f32, 0.18453818656620571 as f32],
        [0.24461592248526617 as f32, 0.6720442513235444 as f32, 0.0833398261911897 as f32],
        [0.0251810508440715 as f32, 0.14118576708477823 as f32, 0.9226909328310285 as f32],
    ];
    pub const XYZ_TO_APPLE_RGB: [[f32; 3]; 3] = [
        [2.951978479694552 as f32, -1.2896043040610905 as f32, -0.47391530718500535 as f32],
        [-1.0850835744336773 as f32, 1.9908093391113184 as f32, 0.03720167780571314 as f32],
        [0.08547221373222354 as f32, -0.26942971179950037 as f32, 1.0910276694054408 as f32],
    ];

    pub const DISPLAY_P3_TO_XYZ: [[f32; 3]; 3] = [
        [0.48657094864821604 as f32, 0.26566769316909306 as f32, 0.1982172852343625 as f32],
        [0.22897456406974873 as f32, 0.6917385218365063 as f32, 0.079286914093745 as f32],
        [-0.0 as f32, 0.04511338185890263 as f32, 1.043944368900976 as f32],
    ];
    pub const XYZ_TO_DISPLAY_P3: [[f32; 3]; 3] = [
        [2.4934969119414263 as f32, -0.9313836179191243 as f32, -0.40271078445071695 as f32],
        [-0.8294889695615748 as f32, 1.7626640603183468 as f32, 0.02362468584194360 as f32],
        [0.03584583024378447 as f32, -0.0761723892680418 as f32, 0.9568845240076873 as f32],
    ];

    pub const ADOBE_RGB_TO_XYZ: [[f32; 3]; 3] = [
        [0.5766690429101305 as f32, 0.1855582379065463 as f32, 0.18822864623499466 as f32],
        [0.29734497525053605 as f32, 0.6273635662554661 as f32, 0.07529145849399786 as f32],
        [0.02703136138641234 as f32, 0.07068885253582723 as f32, 0.9913375368376386 as f32],
    ];
    pub const XYZ_TO_ADOBE_RGB: [[f32; 3]; 3] = [
        [2.041587903810747 as f32, -0.5650069742788597 as f32, -0.34473135077832967 as f32],
        [-0.9692436362808798 as f32, 1.8759675015077206 as f32, 0.04155505740717561 as f32],
        [0.01344428063203115 as f32, -0.11836239223101841 as f32, 1.0151749943912058 as f32],
    ];

    pub const PROPHOTO_RGB_TO_XYZ: [[f32; 3]; 3] = [
        [0.7976661108038989 as f32, 0.13519231336302714 as f32, 0.03134157583307381 as f32],
        [0.28803704804175084 as f32, 0.7118773192373937 as f32, 0.00008563272085539 as f32],
        [0.0 as f32, 0.0 as f32, 0.8249 as f32],
    ];
    pub const XYZ_TO_PROPHOTO_RGB: [[f32; 3]; 3] = [
        [1.3459582063740676 as f32, -0.25561034000154825 as f32, -0.05111233190002151 as f32],
        [-0.5445964045699176 as f32, 1.5081604916604545 as f32, 0.02053504864330213 as f32],
        [0.0 as f32, 0.0 as f32, 1.2122681537156021 as f32],
    ];

    pub const REC2020_TO_XYZ: [[f32; 3]; 3] = [
        [0.6369580483012911 as f32, 0.14461690358620835 as f32, 0.16888097516417208 as f32],
        [0.262700212011267 as f32, 0.6779980715188709 as f32, 0.05930171646986195 as f32],
        [0.0 as f32, 0.02807269304908743 as f32, 1.0609850577107909 as f32],
    ];
    pub const XYZ_TO_REC2020: [[f32; 3]; 3] = [
        [1.7166511879712683 as f32, -0.35567078377639255 as f32, -0.25336628137365985 as f32],
        [-0.6666843518324892 as f32, 1.6164812366349393 as f32, 0.01576854581391114 as f32],
        [0.01763985744531079 as f32, -0.04277061325780853 as f32, 0.9421031212354739 as f32],
    ];

    pub const BT601_625_TO_XYZ: [[f32; 3]; 3] = [
        [0.4305538133299022 as f32, 0.3415498035305534 as f32, 0.17835231019121597 as f32],
        [0.22200430999823084 as f32, 0.706654765925283 as f32, 0.07134092407648639 as f32],
        [0.02018220999983915 as f32, 0.12955337375296855 as f32, 0.9393221670070708 as f32],
    ];
    pub const XYZ_TO_BT601_625: [[f32; 3]; 3] = [
        [3.0633610900832724 as f32, -1.3933901749073678 as f32, -0.47582373799753014 as f32],
        [-0.9692436362808795 as f32, 1.87596750150772 as f32, 0.04155505740717561 as f32],
        [0.06786104755356688 as f32, -0.22879926962049577 as f32, 1.0690896180160279 as f32],
    ];

    pub const BT601_525_TO_XYZ: [[f32; 3]; 3] = [
        [0.39352090365938974 as f32, 0.3652580767176036 as f32, 0.19167694667467827 as f32],
        [0.2123763607050675 as f32, 0.7010598569257229 as f32, 0.08656378236920956 as f32],
        [0.01873909065044711 as f32, 0.11193392673603976 as f32, 0.9583847333733914 as f32],
    ];
    pub const XYZ_TO_BT601_525: [[f32; 3]; 3] = [
        [3.506003282724663 as f32, -1.7397907263028323 as f32, -0.5440582683627413 as f32],
        [-1.069047559853815 as f32, 1.9777788827287865 as f32, 0.03517141933719514 as f32],
        [0.0563065917341277 as f32, -0.19697565482077187 as f32, 1.0499523282187335 as f32],
    ];

    pub const NTSC_1953_TO_XYZ: [[f32; 3]; 3] = [
        [0.6069370511550323 as f32, 0.17350884116135754 as f32, 0.2002625200808271 as f32],
        [0.29893914459874726 as f32, 0.5866251296407803 as f32, 0.11443572576047262 as f32],
        [-0.0 as f32, 0.06609860615670769 as f32, 1.115748326164608 as f32],
    ];
    pub const XYZ_TO_NTSC_1953: [[f32; 3]; 3] = [
        [1.9098509307175413 as f32, -0.5324136865683171 as f32, -0.28818722483973136 as f32],
        [-0.9846224942838822 as f32, 1.999082033849094 as f32, -0.02830694039510768 as f32],
        [0.05833051498847057 as f32, -0.11842862134022794 as f32, 0.897936412549787 as f32],
    ];

    // -------------------------------------------------------------------------
    // CHROMATIC ADAPTATION MATRICES
    // -------------------------------------------------------------------------

    pub const BRADFORD: [[f32; 3]; 3] = [
        [0.8951 as f32, 0.2664 as f32, -0.1614 as f32],
        [-0.7502 as f32, 1.7135 as f32, 0.0367 as f32],
        [0.0389 as f32, -0.0685 as f32, 1.0296 as f32],
    ];
    pub const BRADFORD_INV: [[f32; 3]; 3] = [
        [0.9869929054667123 as f32, -0.14705425642099013 as f32, 0.15996265166373125 as f32],
        [0.43230526972339456 as f32, 0.5183602715367776 as f32, 0.0492912282128556 as f32],
        [-0.00852866457517733 as f32, 0.04004282165408487 as f32, 0.9684866957875502 as f32],
    ];

    pub const ADAPT_D50_TO_D65: [[f32; 3]; 3] = [
        [0.9555125889283475 as f32, -0.02307297517304352 as f32, 0.06330908471330188 as f32],
        [-0.02832475931011879 as f32, 1.0099429264007957 as f32, 0.021054438751389 as f32],
        [0.01232870317482127 as f32, -0.02053530765430329 as f32, 1.330713689917589 as f32],
    ];
    pub const ADAPT_D65_TO_D50: [[f32; 3]; 3] = [
        [1.0478860032225505 as f32, 0.02291876517477952 as f32, -0.05021609531173302 as f32],
        [0.02958178249800350 as f32, 0.9904835184905488 as f32, -0.0170787077044827 as f32],
        [-0.00925188083920884 as f32, 0.01507260748703133 as f32, 0.7516781336176036 as f32],
    ];

    // -------------------------------------------------------------------------
    // DIRECT RGB <-> sRGB MATRICES
    // -------------------------------------------------------------------------

    pub const APPLE_RGB_TO_SRGB: [[f32; 3]; 3] = [
        [1.0687158545276882 as f32, -0.07860969598003947 as f32, 0.00989384145235139 as f32],
        [0.02410625513491821 as f32, 0.9600709276463433 as f32, 0.01582281721873901 as f32],
        [0.00173435335705017 as f32, 0.02974114446536134 as f32, 0.9685245021775882 as f32],
    ];
    pub const SRGB_TO_APPLE_RGB: [[f32; 3]; 3] = [
        [0.9339874165842391 as f32, 0.07680843758720021 as f32, -0.01079585417143902 as f32],
        [-0.02343562489314104 as f32, 1.0401898373846301 as f32, -0.01675421249148942 as f32],
        [-0.00095285344225948 as f32, -0.03207936312068568 as f32, 1.0330322165629455 as f32],
    ];

    pub const DISPLAY_P3_TO_SRGB: [[f32; 3]; 3] = [
        [1.2249401762805598 as f32, -0.22494017628055996 as f32, -0.0 as f32],
        [-0.04205695470968812 as f32, 1.0420569547096883 as f32, 0.0 as f32],
        [-0.01963755459033444 as f32, -0.0786360455506318 as f32, 1.0982736001409663 as f32],
    ];
    pub const SRGB_TO_DISPLAY_P3: [[f32; 3]; 3] = [
        [0.8224619687143624 as f32, 0.17753803128563794 as f32, 0.0 as f32],
        [0.03319419885096169 as f32, 0.9668058011490385 as f32, 0.0 as f32],
        [0.01708263072112004 as f32, 0.07239744066396342 as f32, 0.9105199286149166 as f32],
    ];

    pub const ADOBE_RGB_TO_SRGB: [[f32; 3]; 3] = [
        [1.3983557439607786 as f32, -0.39835574396077855 as f32, 0.0 as f32],
        [-0.0 as f32, 1.0 as f32, -0.0 as f32],
        [-0.0 as f32, -0.04292898929447317 as f32, 1.0429289892944729 as f32],
    ];
    pub const SRGB_TO_ADOBE_RGB: [[f32; 3]; 3] = [
        [0.7151256068556247 as f32, 0.28487439314437574 as f32, 0.0 as f32],
        [-0.0 as f32, 1.0 as f32, -0.0 as f32],
        [0.0 as f32, 0.04116194845011842 as f32, 0.958838051549882 as f32],
    ];

    pub const REC2020_TO_SRGB: [[f32; 3]; 3] = [
        [1.6604910021084347 as f32, -0.5876411387885496 as f32, -0.07284986331988486 as f32],
        [-0.12455047452159052 as f32, 1.13289989712596 as f32, -0.00834942260436949 as f32],
        [-0.01815076335490522 as f32, -0.10057889800800737 as f32, 1.1187296613629125 as f32],
    ];
    pub const SRGB_TO_REC2020: [[f32; 3]; 3] = [
        [0.627403895934699 as f32, 0.32928303837788375 as f32, 0.04331306568741727 as f32],
        [0.06909728935823199 as f32, 0.919540395075459 as f32, 0.01136231556630915 as f32],
        [0.01639143887515023 as f32, 0.08801330787722578 as f32, 0.895595253247624 as f32],
    ];

    pub const PROPHOTO_RGB_TO_SRGB: [[f32; 3]; 3] = [
        [2.0342181530788603 as f32, -0.7275364732863576 as f32, -0.30668167979250266 as f32],
        [-0.22879805605430628 as f32, 1.2317302821191265 as f32, -0.00293222606482029 as f32],
        [-0.00855553292091616 as f32, -0.1532865748773777 as f32, 1.1618421077982937 as f32],
    ];
    pub const SRGB_TO_PROPHOTO_RGB: [[f32; 3]; 3] = [
        [0.529312458714951 as f32, 0.3301361988565311 as f32, 0.14055134242851772 as f32],
        [0.09836174743191933 as f32, 0.8734700897221939 as f32, 0.02816816284588725 as f32],
        [0.01687499996529928 as f32, 0.1176715222416342 as f32, 0.865453477793067 as f32],
    ];

    // -------------------------------------------------------------------------
    // TRANSFER FUNCTION CONSTANTS
    // -------------------------------------------------------------------------

    /// sRGB encode threshold (linear space) - derived for continuous value AND slope
    pub const SRGB_THRESHOLD: f32 = 0.00303993463977843 as f32;
    /// sRGB decode threshold (encoded space)
    pub const SRGB_DECODE_THRESHOLD: f32 = 0.03928571428571428 as f32;
    /// sRGB linear slope - derived for continuous value AND slope
    pub const SRGB_LINEAR_SLOPE: f32 = 12.92321018078785 as f32;
    pub const SRGB_GAMMA: f32 = 2.4;
    pub const SRGB_SCALE: f32 = 1.055;
    pub const SRGB_OFFSET: f32 = 0.055;

    pub const ADOBE_RGB_GAMMA: f32 = 2.19921875 as f32;
    pub const APPLE_RGB_GAMMA: f32 = 1.8 as f32;

    pub const PROPHOTO_THRESHOLD: f32 = 0.001953125 as f32;
    pub const PROPHOTO_DECODE_THRESHOLD: f32 = 0.03125 as f32;
    pub const PROPHOTO_LINEAR_MULTIPLIER: f32 = 16.0 as f32;
    pub const PROPHOTO_GAMMA: f32 = 1.8 as f32;

    pub const GAMMA_22: f32 = 2.2;

    // -------------------------------------------------------------------------
    // CIELAB CONSTANTS
    // -------------------------------------------------------------------------

    pub const CIELAB_DELTA: f32 = 0.20689655172413793 as f32;
    pub const CIELAB_EPSILON: f32 = 0.00885645167903563 as f32;
    pub const CIELAB_KAPPA: f32 = 7.787037037037036 as f32;
    pub const CIELAB_OFFSET: f32 = 0.13793103448275862 as f32;
    pub const CIELAB_F_THRESHOLD: f32 = 0.20689655172413793 as f32;
    /// Negative threshold: where linear segment meets cbrt for t < 0
    pub const CIELAB_NEG_EPSILON: f32 = 0.07085161343228505 as f32;
    /// f(-NEG_EPSILON) threshold in f-space for inverse
    pub const CIELAB_NEG_F_THRESHOLD: f32 = -0.41379310344827586 as f32;
    pub const CIELAB_L_SCALE: f32 = 116.0;
    pub const CIELAB_L_OFFSET: f32 = 16.0;
    pub const CIELAB_A_SCALE: f32 = 500.0;
    pub const CIELAB_B_SCALE: f32 = 200.0;

    // -------------------------------------------------------------------------
    // CIE94 COLOR DIFFERENCE CONSTANTS
    // -------------------------------------------------------------------------

    /// CIE94 K1 coefficient for SC = 1 + K1*C
    pub const CIE94_K1: f32 = 0.045 as f32;
    /// CIE94 K2 coefficient for SH = 1 + K2*C
    pub const CIE94_K2: f32 = 0.015 as f32;

    // -------------------------------------------------------------------------
    // CIEDE2000 COLOR DIFFERENCE CONSTANTS
    // -------------------------------------------------------------------------

    /// 25^7 - chroma correction threshold (exact integer)
    pub const CIEDE2000_POW25_7: f32 = 6103515625.0 as f32;
    /// T factor: 30° in radians (derived: π/6)
    pub const CIEDE2000_T_30_RAD: f32 = 0.5235987755982988 as f32;
    /// T factor: 6° in radians (derived: π/30)
    pub const CIEDE2000_T_6_RAD: f32 = 0.10471975511965977 as f32;
    /// T factor: 63° in radians (derived: 7π/20)
    pub const CIEDE2000_T_63_RAD: f32 = 1.0995574287564276 as f32;
    /// RT term: 275° in radians (derived: 55π/36)
    pub const CIEDE2000_RT_275_RAD: f32 = 4.799655442984406 as f32;
    /// RT term: 25° in radians (derived: 5π/36)
    pub const CIEDE2000_RT_25_RAD: f32 = 0.4363323129985824 as f32;
    /// RT term: 30° for Δθ in radians (derived: π/6)
    pub const CIEDE2000_RT_30_RAD: f32 = 0.5235987755982988 as f32;
    /// SL weighting function: L* midpoint (primary)
    pub const CIEDE2000_SL_L_MIDPOINT: f32 = 50.0 as f32;
    /// SL weighting function: denominator offset (primary)
    pub const CIEDE2000_SL_DENOM_OFFSET: f32 = 20.0 as f32;

    // -------------------------------------------------------------------------
    // OKLAB MATRICES (from primary constants)
    // -------------------------------------------------------------------------

    /// OKLab M1: Linear sRGB → LMS
    pub const OKLAB_M1: [[f32; 3]; 3] = [
        [0.4122214708 as f32, 0.5363325363 as f32, 0.0514459929 as f32],
        [0.2119034982 as f32, 0.6806995451 as f32, 0.1073969566 as f32],
        [0.0883024619 as f32, 0.2817188376 as f32, 0.6299787005 as f32],
    ];

    /// OKLab M2: LMS' → Lab
    pub const OKLAB_M2: [[f32; 3]; 3] = [
        [0.2104542553 as f32, 0.793617785 as f32, -0.0040720468 as f32],
        [1.9779984951 as f32, -2.428592205 as f32, 0.4505937099 as f32],
        [0.0259040371 as f32, 0.7827717662 as f32, -0.808675766 as f32],
    ];

    /// OKLab M1_inv: LMS → Linear sRGB
    pub const OKLAB_M1_INV: [[f32; 3]; 3] = [
        [4.0767416621 as f32, -3.3077115913 as f32, 0.2309699292 as f32],
        [-1.2684380046 as f32, 2.6097574011 as f32, -0.3413193965 as f32],
        [-0.0041960863 as f32, -0.7034186147 as f32, 1.707614701 as f32],
    ];

    /// OKLab M2_inv: Lab → LMS'
    pub const OKLAB_M2_INV: [[f32; 3]; 3] = [
        [1.0 as f32, 0.3963377774 as f32, 0.2158037573 as f32],
        [1.0 as f32, -0.1055613458 as f32, -0.0638541728 as f32],
        [1.0 as f32, -0.0894841775 as f32, -1.291485548 as f32],
    ];

    // -------------------------------------------------------------------------
    // Y'CbCr CONSTANTS
    // -------------------------------------------------------------------------

    /// BT.709 luma coefficients (derived from sRGB matrix)
    pub const YCBCR_KR: f32 = 0.21263900587151024 as f32;
    pub const YCBCR_KG: f32 = 0.715168678767756 as f32;
    pub const YCBCR_KB: f32 = 0.07219231536073371 as f32;
    pub const YCBCR_CB_SCALE: f32 = 1.8556153692785327 as f32;
    pub const YCBCR_CR_SCALE: f32 = 1.5747219882569796 as f32;

    pub const RGB_TO_YCBCR: [[f32; 3]; 3] = [
        [0.21263900587151024 as f32, 0.715168678767756 as f32, 0.07219231536073371 as f32],
        [-0.11459217755573169 as f32, -0.3854078224442683 as f32, 0.5 as f32],
        [0.5 as f32, -0.45415551703787305 as f32, -0.04584448296212691 as f32],
    ];
    pub const YCBCR_TO_RGB: [[f32; 3]; 3] = [
        [1.0 as f32, 0.0 as f32, 1.5747219882569796 as f32],
        [1.0 as f32, -0.18731408953478898 as f32, -0.46820747055634204 as f32],
        [1.0 as f32, 1.8556153692785327 as f32, 0.0 as f32],
    ];

    /// BT.601 625-line (PAL/SECAM) true luminance coefficients
    /// Derived from RGB→XYZ matrix. NOT the legacy 0.299/0.587/0.114 values.
    pub const BT601_625_KR: f32 = 0.22200430999823084 as f32;
    pub const BT601_625_KG: f32 = 0.706654765925283 as f32;
    pub const BT601_625_KB: f32 = 0.07134092407648639 as f32;

    /// BT.601 525-line (NTSC) true luminance coefficients
    /// Derived from RGB→XYZ matrix. NOT the legacy 0.299/0.587/0.114 values.
    pub const BT601_525_KR: f32 = 0.2123763607050675 as f32;
    pub const BT601_525_KG: f32 = 0.7010598569257229 as f32;
    pub const BT601_525_KB: f32 = 0.08656378236920956 as f32;

    /// NTSC 1953 luma coefficients (Y row of RGB→XYZ matrix).
    /// These round to the traditional 0.299/0.587/0.114 values.
    pub const NTSC_1953_KR: f32 = 0.29893914459874726 as f32;
    pub const NTSC_1953_KG: f32 = 0.5866251296407803 as f32;
    pub const NTSC_1953_KB: f32 = 0.11443572576047262 as f32;

    // -------------------------------------------------------------------------
    // BT.601 / ITU-T T.871 Y'CbCr ENCODING
    // -------------------------------------------------------------------------

    /// BT.601 Y'CbCr encoding coefficients (also used by JPEG/ITU-T T.871).
    pub const BT601_KR: f32 = 0.299 as f32;
    pub const BT601_KG: f32 = 0.587 as f32;
    pub const BT601_KB: f32 = 0.114 as f32;
    pub const BT601_CB_SCALE: f32 = 1.772 as f32;
    pub const BT601_CR_SCALE: f32 = 1.402 as f32;
    /// Cb row: [CB_R, CB_G, CB_B]
    pub const BT601_CB_R: f32 = -0.16873589164785552 as f32;
    pub const BT601_CB_G: f32 = -0.3312641083521444 as f32;
    pub const BT601_CB_B: f32 = 0.5 as f32;
    /// Cr row: [CR_R, CR_G, CR_B]
    pub const BT601_CR_R: f32 = 0.5 as f32;
    pub const BT601_CR_G: f32 = -0.41868758915834514 as f32;
    pub const BT601_CR_B: f32 = -0.08131241084165478 as f32;

    // -------------------------------------------------------------------------
    // BIT DEPTH
    // -------------------------------------------------------------------------

    pub const UINT8_MAX: f32 = 255.0;
    pub const UINT16_MAX: f32 = 65535.0;
}

// =============================================================================
// TESTS
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    fn mat_mul(a: [[f64; 3]; 3], b: [[f64; 3]; 3]) -> [[f64; 3]; 3] {
        let mut r = [[0.0; 3]; 3];
        for i in 0..3 {
            for j in 0..3 {
                for k in 0..3 {
                    r[i][j] += a[i][k] * b[k][j];
                }
            }
        }
        r
    }

    fn is_identity(m: [[f64; 3]; 3], tol: f64) -> bool {
        for i in 0..3 {
            for j in 0..3 {
                let expected = if i == j { 1.0 } else { 0.0 };
                if (m[i][j] - expected).abs() > tol {
                    return false;
                }
            }
        }
        true
    }

    #[test]
    fn test_srgb_matrices_are_inverses() {
        let product = mat_mul(SRGB_TO_XYZ, XYZ_TO_SRGB);
        assert!(is_identity(product, 1e-10), "SRGB matrices not inverse");
    }

    #[test]
    fn test_apple_matrices_are_inverses() {
        let product = mat_mul(APPLE_RGB_TO_XYZ, XYZ_TO_APPLE_RGB);
        assert!(is_identity(product, 1e-10), "Apple RGB matrices not inverse");
    }

    #[test]
    fn test_p3_matrices_are_inverses() {
        let product = mat_mul(DISPLAY_P3_TO_XYZ, XYZ_TO_DISPLAY_P3);
        assert!(is_identity(product, 1e-10), "Display P3 matrices not inverse");
    }

    #[test]
    fn test_adobe_matrices_are_inverses() {
        let product = mat_mul(ADOBE_RGB_TO_XYZ, XYZ_TO_ADOBE_RGB);
        assert!(is_identity(product, 1e-10), "Adobe RGB matrices not inverse");
    }

    #[test]
    fn test_prophoto_matrices_are_inverses() {
        let product = mat_mul(PROPHOTO_RGB_TO_XYZ, XYZ_TO_PROPHOTO_RGB);
        assert!(is_identity(product, 1e-10), "ProPhoto RGB matrices not inverse");
    }

    #[test]
    fn test_rec2020_matrices_are_inverses() {
        let product = mat_mul(REC2020_TO_XYZ, XYZ_TO_REC2020);
        assert!(is_identity(product, 1e-10), "Rec.2020 matrices not inverse");
    }

    #[test]
    fn test_ycbcr_matrices_are_inverses() {
        let product = mat_mul(RGB_TO_YCBCR, YCBCR_TO_RGB);
        assert!(is_identity(product, 1e-10), "Y'CbCr matrices not inverse");
    }

    #[test]
    fn test_cielab_epsilon() {
        let expected = (6.0_f64 / 29.0).powi(3);
        assert!((cielab::EPSILON - expected).abs() < 1e-15);
    }

    #[test]
    fn test_cielab_kappa() {
        let expected = (29.0_f64 / 6.0).powi(2) / 3.0;
        assert!((cielab::KAPPA - expected).abs() < 1e-12);
    }

    #[test]
    fn test_srgb_white_matches_d65() {
        // RGB (1,1,1) maps to white XYZ via matrix row sums.
        // This should match D65 since sRGB matrices are derived from D65 (0.3127, 0.3290).
        let x = SRGB_TO_XYZ[0][0] + SRGB_TO_XYZ[0][1] + SRGB_TO_XYZ[0][2];
        let y = SRGB_TO_XYZ[1][0] + SRGB_TO_XYZ[1][1] + SRGB_TO_XYZ[1][2];
        let z = SRGB_TO_XYZ[2][0] + SRGB_TO_XYZ[2][1] + SRGB_TO_XYZ[2][2];
        assert!((x - d65::XYZ_X).abs() < 1e-14, "X: {} vs {}", x, d65::XYZ_X);
        assert!((y - d65::XYZ_Y).abs() < 1e-14, "Y: {} vs {}", y, d65::XYZ_Y);
        assert!((z - d65::XYZ_Z).abs() < 1e-14, "Z: {} vs {}", z, d65::XYZ_Z);
    }

    #[test]
    fn test_apple_direct_matrices_are_inverses() {
        let product = mat_mul(APPLE_RGB_TO_SRGB, SRGB_TO_APPLE_RGB);
        assert!(is_identity(product, 1e-10), "Apple RGB direct matrices not inverse");
    }

    #[test]
    fn test_p3_direct_matrices_are_inverses() {
        let product = mat_mul(DISPLAY_P3_TO_SRGB, SRGB_TO_DISPLAY_P3);
        assert!(is_identity(product, 1e-10), "Display P3 direct matrices not inverse");
    }

    #[test]
    fn test_adobe_direct_matrices_are_inverses() {
        let product = mat_mul(ADOBE_RGB_TO_SRGB, SRGB_TO_ADOBE_RGB);
        assert!(is_identity(product, 1e-10), "Adobe RGB direct matrices not inverse");
    }

    #[test]
    fn test_rec2020_direct_matrices_are_inverses() {
        let product = mat_mul(REC2020_TO_SRGB, SRGB_TO_REC2020);
        assert!(is_identity(product, 1e-10), "Rec.2020 direct matrices not inverse");
    }

    #[test]
    fn test_prophoto_direct_matrices_are_inverses() {
        let product = mat_mul(PROPHOTO_RGB_TO_SRGB, SRGB_TO_PROPHOTO_RGB);
        assert!(is_identity(product, 1e-10), "ProPhoto RGB direct matrices not inverse");
    }

    #[test]
    fn test_bradford_matrices_are_inverses() {
        let product = mat_mul(BRADFORD, BRADFORD_INV);
        assert!(is_identity(product, 1e-10), "Bradford matrices not inverse");
    }

    #[test]
    fn test_d50_d65_adaptation_roundtrip() {
        let product = mat_mul(ADAPT_D50_TO_D65, ADAPT_D65_TO_D50);
        assert!(is_identity(product, 1e-10), "D50<->D65 adaptation not inverse");
    }
}
